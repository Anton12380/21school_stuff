
#  Cи за 42 минуты (ну почти) / [C in 42 min (almost)](https://youtu.be/tUfXuSI7rUU) #

Привет всем и добро пожаловать на этот урок: Cи за 42 минуты / (ну почти).

> Hello everyone, and welcome to this lesson : C in 42 minutes (almost)

## 1. Предисловие / Foreword ##

#### 1.1 - Это не урок по Си / This is not a C lesson ####

Прежде всего, небольшое уточнение: этот урок не предназначен для того, чтобы научить вас программировать на Cи. Это не полное описание языка. Его единственная цель - показать элементы, которые вам понадобятся, чтобы закончить этот бассейн.

#### 1.2 - Введение в Си "бассейна" / Introduction to the C "pool" ####

Это подраздел Си позволит вам выполнить все то, что от вас требуется во время этого бассейна.

---

> Before anything, small clarification : this lesson is not meant to teach you how to program in C. It's not an exhaustive description of the language. Its sole purpose is to bring forward elements you'll need to complete this piscine. It's a subset of C, which will allow you to accomplish everything that's asked of you during this piscine.

## 2. Что такое компьютер? / What is a computer? ##

Перед тем, как начать писать код, первое, что вам нужно понять:
* Что такое компьютер?
* Что внутри него?
* И как это работает?

Итак, машина состоит из 3 элементов:
1. Первый элемент - это процессор "ЦП" ("CPU"). Это то, что обрабатывает все вычисления, сравнения. Все эти действия выполняются процессором.
2. Второй элемент - это оперативная память "ОЗУ" ("RAM"). "ОЗУ" - это инструмент, объект, который хранит все то, что запомнил компьютер. [alt: хранит все то, что происходит на компьютере (данные обрабатываемые процессором и машинный код (программы))]. Так что этот второй элемент очень важен.
3. И, наконец, третий элемент сделан из компьютерной периферии / устройств ("devices"), которые обеспечивают вам соединение (связь) между вашим компьютером и остальным миром.

И так, мы имеем эти 3 элемента.

Эти 3 элемента связаны между собой системой, называемой "BUS" (компьютерной шиной), которая позволяет информации передаваться. Также есть "clock" система [alt: сиcтема синхронизации (генератор тактовых импульсов)], которая позволяет элементам, всему этому, работать вместе. Конечно, компьютер гораздо сложнее, чем в моем описании, но именно такое, я бы сказал видение, или хотя бы представление нам понадобится во время бассейна, а также, на некоторое время, в течении 1-го года в школе. Итак, давайте пока оставим это базовое описание.

Я повторюсь: процессор "ЦП", то есть блок обработки данных; система памяти, которую мы называем "ОЗУ" и периферийные  устройства, система взаимодействия с остальным миром.

---

> Before even starting to write code, the 1st thing you need to understand is... What's a computer? What's in it? And how does it work?
> So, a machine is made of 3 elements. The first is the CPU. It's the one that processes all calculations, all comparisons, ... All of these actions are made by the CPU. The second element is the RAM. The RAM is a tool, an object that'll hold everything that's been memorised by the computer. So this second element is very important. And last, the 3rd element is made of computer peripherals/devices. That's what will allow you to connect your computer to the rest of the world. So we have those 3 elements. These 3 elements are interlinked by a system, called BUS which will allow information to be transferred. There's also a clock system,  which allows all of this to operate together. So, of course a computer is much more complex than what I've described. But that's, I would say, the image. or at least the representation we'll need during the rest of this piscine, and also, for a while, during 1st year at the school. So let's keep this basic description for now.
> I'll say it again: a processor (CPU), so a treatment unit, a memorisation system, which we call RAM, and a system of interface with the rest of the world in other words, devices.

## 3. А само программирование, что это такое? / And programming, what does that mean? ##

#### 3.1 - Инструкции для процессора / Instructions for the CPU ####

Программирование, по итогу, (в сравнении с тем, что мы до это этого видели, имея в виду парадигму описания компьютера), состоит в том, чтобы давать какие-либо инструкции процессору, то есть список элементарных действий, которые будут обрабатывать данные.

#### 3.2 - Данные на обработку / Data to handle ####

Так что мы сможем выполнять чрезвычайно простые действия. Например, сравнение двух данных, простая операция, такая как сложение, вычитание или деление. Мы сможем перенаправлять информацию в новый адрес, таким образом, скопировав данные адреса в другой. Мы сможем выполнять базовую арифметику, базовые сравнения и мы сможем отправлять эти данные на устройства, например, отображать их на экране или просто отправить их куда-либо.

#### 3.3 - И то, и то находится в ОЗУ / Both are in RAM ####

Что вы должны понимать, так это то, что мы стараемся сделать вещи, которые являются очень элементарными, НО выполнены они будут очень быстро и в очень большом количестве. Эти элементарные инструкции позволят нам симулировать чрезвычайно сложное поведение, возможно даже симулировать интеллект.

В любом случае, на сегодняшний день, наша система программирования имеет возможность выполнять не только элементарные вещи.

---

> Programming, in the end, compared to what we've seen before, meaning the paradigm of the computer's description, consists in giving instructions to the processor, meaning a list of elementary actions which will handle data.
> So we'll be able to do extremely simple actions. Like, for example, comparing two data, a simple operation such as an addition, a subtraction or a division. We'll be able to relay an information in a new address, so, we'll be able to copy the data of an address into another. We'll be able to do basic arithmetics, basic comparisons, and we'll be able to send these data to a device, for example, display them onscreen, or simply forward them.
> What you need to understand, is that we're trying to do things that are extremely elementary, but that will be done extremely fast and in a very large quantity. These elementary instructions will allow us to simulate extremely complicated behaviors, maybe even simulate intelligence.
> However, today, our programming sytem won't be able to just do extremely elementary things.

## 4. Так, что там насчет Си? / So what about C in all that? ##

#### 4.1 - Простые языки программирования / Simple languages ####

В конце концов, компьютер будет обрабатывать язык, который называется компьютерным языком, который является очень элементарным языком, непосредственно составленным из машинного кода («машинный язык»), который довольно сложен для человеческих существ.

Язык Си - это некий внешний слой всего этого. Это относительно простой язык, близкий к языку компьютера, тут этот язык будет являться последовательным языком, который в целом имеет перевод довольно элементарных операций.

Так что, ничего сложного тут нет. В любом случае, язык будет читаемым и довольно простым для того, чтобы человек мог его использовать, что само по себе делает сам процесс работы с ним более эффективным.

#### 4.2 - Компилируемые языки / Compiled languages ####

Итак, у нас есть сложная система, значит мы преобразуем язык Си, (код который мы записали куда-то), в компьютерный язык. Потом, этот компьютерный язык будет обработан процессором, и он будет являться читаемым для людей, и он будет компилироваться (так что он еще более эффективен), давая набор функциональных возможностей, которые относительно эволюционировали, что позволят нам нормально работать.

#### 4.3 - Среда операционных систем  / Operating system's environment ####

Операционная система - это еще один важный слой для интеграции. Операционная система - это программное обеспечение, которое заставляет компьютер работать. Она запускается при запуске самой машины и позволяет иметь интерфейс между самой машиной и пользователем. ОС - Операционная система. Позже, мы увидим более полные определения и описания, потому что сам по себе очень сложный объект, который разрабатывался в течении очень долгого времени и над которым было проделано много работ. ОС - это результат сильной эволюции.

И этот объейкт, ОС, будет управлять всем функционированием компьютера, а ваша программа будет "взаимодействовать" с этой ОС. Чтобы было понятнее, когда например вы захотите отобразить символ, то ваша программа, написанная на Си, скажет ОС через "системные вызовы": "Я хочу, чтобы этот символ был отображен" и именно ОС выполнит эту работу. А это значит, что в вашей программе не нужно писать код всей системы, которая должна придти к отображению символа.

Итак, Си дает вам возможность написать простые инструкции, которые позволят вам "взаимодействовать" с ОС (операционной системой), которая в свою очередь будет также "взаимодействовать" с аппаратной частью, для отображения или выполнения необходимых вам действий.

---

> So what about C in all that? In the end, the computer will process a language, which is called computer-language, which is a very elementary language, directly made of codes that are particularly unpleasant for human beings.
> The C language is a layer above of this. It's a relatively simple language, that's close to the computer's language. Here, we'll have a sequential language which will, overall, have a translation in rather elementary operations. So nothing too complicated. However, it'll be readable and pretty simple to use by a human being. which will make this process efficient.
> So, we have a system that will be complicated, meaning we'll transform the C language into something we write in computer language. Then, this computer language will be executed by the processor, and it'll be readable by human beings, and it'll compile (so it's particularly efficient) all by letting a set of functionalities, that are relatively evolved, allowing us to function correctly.
> Another important layer to integrate, is the operating system. The operating system is the software that'll make the computer work. It'll be launched at the start-up, and will allow us to have an interface between the user and the machine. The OS, we'll see more complex definitions and descriptions later on, because it's a very complex object that's been elaborated with a lot of work for a very long time, The OS is the result of a strong evolution.
> This object will manage the entire functioning of the computer and your program will 'interface" itself with the OS. To be clear, when, for example, you'll want to display a character, your program, written in C, will tells the OS via what we call system-calls, "I want this character to be displayed" And it's the OS that'll do the job. Which means, in your program, you don't need to code the entire system, that'll lead to displaying a character.
> So, C will allow your to write simple instructions, which will allow you to "interface" with the OS, which will also "interface" itself with the hardware to display or to cary out the actions you need.

## 5. Инструкции и информация / Instructions and informations ##

#### 5.1 - Программа на Си имеет и то, и то / A C program has both ####

Как мы видели ранее, компьютер имеет память, следовательно он хранит данные, тоесть следуя инструкциям он сможет выполнять процессы над этими данными.

#### 5.2 - ОЗУ (RAM) - это последовательность байтов (8 бит) / RAM is a sequence of bytes (8 bits) ####

Программа на языке Си - это своего рода представление, не только данных, которые мы будем обрабатывать (что означает, что мы получим информацию об этих данных), но также и инструкций. В ОЗУ данные отображаются группами по 8, которые называются байтами. Эта группа состоит из 8 битов, и так 8: 1 и 0, и все это мы зовем байтом (8 bit = 10110101 => 1 byte).

Размер | Название | Пример
-------|----------|-------
1      | Bit      | 0
8      | Byte	    | 10110101

#### 5.3 - Каждый байт имеет уникальный адрес в ОЗУ / Each byte has a unique address in RAM ####

Он (1 байт) позволяет нам хранить числа от 0 до 255, в зависимости от их представления.

> В русском языке октет обычно называют byte (октет = 1byte = 8bit) может принимать 256 возможных состояний (кодов, значений, комбинаций битов (нулей и единиц). ru.wikipedia.org/wiki/Байт

#### 5.4 - Си должна получать доступ к байтам, чтобы хранить информацию / C must access bytes in order to store informations ####

И каждому из этих байтов, будет дан (присвоен) адрес, который позволит нам его распознать и найти. Язык Си позволит нам работать с этими байтами и, таким образом, работать с адресной системой.

---

> As we've seen previously, the computer holds memory, so it holds data, and will be able to run processes on these data, so follow instructions.
> A C program, is the representation of not only data we'll process, which means we'll have information about these data, but also instructions. In the RAM, we'll depict the data by groups of 8, which we call bytes. It's a group of 8 bits, so 8, 1 and 0, we'll call that a byte.
>
> It allows us to represent numbers from 0 to 255, depending on their representation. and each of these bytes, will be given an address, which will allow us to recognise it, and find it. C will allow us to work on these bytes, and so work on the address system.

## 6. Система типов Си / C types ##
Си использует типы для представления данных, поэтому у нас будет несколько типов.

Тип                | Число байтов | Диапазон
-------------------|--------------|---------
char               | 1 – 8 bit    | -128 / +127
unsigned char      | 1 – 8 bit	  | 0 / 255
short	             | 2 – 16 bit	  | -32768 / +32767
unsigned short     | 2 – 16 bit   |	0 / 65536
int	               | 4 – 32 bit   | −2147483648 / 2147483647
unsigned int       | 4 – 32 bit	  | 0 / 4 294 967 295
long long          | 8 – 64 bit   |	−9223372036854775808 / +922…
unsigned long long | 8 – 64 bit	  | 0 / 18446744073709551615
\*	               | 8 – 64 bit   |	адрес

1. Первый тип - обычно мы называем его `CHAR`, который является 8-битным, то есть 1 байтом. Таким образом, он может хранить значения в диапазоне от -128 до +127, и на него может воздействовать базовая арифметика, которая позволит ему обрабатывать все обычные процессы: деления, вычитания и т.д.
2. Второй тип - это `UNSIGNED CHAR`, который также является 8-битным, но хранить значения он может в диапазоне от 0 до 255.
3. Далее, у вас есть то, что мы обычно называем `SHORT`, который является 2-байтным, то есть из 16-бит, который дает возможность нам хранить значения в диапазоне от -32768 до +32767.
4. У вас также есть `UNSIGNED SHORT`, опустим подробности...
5. Есть `INT`, который составляет 4-байта и как правило это структура данных, которую мы используем чаще всего, потому что она позволяет нам выполнять большинство процессов.
6. Также у вас есть `UNSIGNED INT`, `LONG` и `LONG LONG`, которые позволяют нам хранить данные до 64-бит. У нас конечно также есть `UNSIGNED LONG LONG`.
7. И у вас есть последний тип - `*`, который называется "звезда / астериск / указатель", который позволяет хранить не только данные, но и адрес данных. Можно считать, что адрес данных - это тоже данные, но существует специальная арифметика, которую мы увидим чуть позже.

---

> C uses types to represent data, and so we'll have several types. The first type, is what we call CHAR, which is 8-bit, so a byte. So it can represent numbers from -128 to +127, and a basic arithmetics is affected to it, which will allow it to handles all usual processes: divisions, subtractions, etc... The second type is the UNSIGNED CHAR, which is also 8 bits, but that'll have another representation, which will go from 0 to 255. Then, you have what we call a SHORT, which is 2 bytes, out of 16-bits, which will allow us to represent from - 32 000 up to +32 000. You also have the UNSIGNED SHORT, skipping details... You have the INT, which is on 4 bytes, and it generally is the data structure we use the most, because it allows us to do most processes. You also have the UNSIGNED INT, the LONG, and the LONG LONG, which allow us to represent data up to 64 bits. You have the UNSIGNED LONG... And you have the last type, which is called the "star", "asterisk" or "pointer", which allows to hold not just a data, but the address of a data. We can consider that a data's address is also a data itself, but there's a special arithmetic that we'll see later on.

---

## 7. Структура программы / Structute of a program ##

#### 7.1 - Программа - это набор функций / A program is a set of functions ####

Теперь, когда мы знаем, как представлять данные, давайте поговорим о структуре программ. Структура программ - это набор функций.

#### 7.2 Фнукция - это закрытый объект, который имеет: / A funtion is a closed entity that has: ####

* Входные данные: параметры / Input data: the parameters
* Фрагмент выходных данных: возвращаемое значение / A piece of output data: the return value

То, что мы называем функцией, это объект, (который считается закрытым, поскольку предполагается, что данные в этом объекте должны быть закрыты для остального мира), который получает информацию (параметры) и который возвращает результат, и между этими всем существует процесс, и мы увидим как это все работает.

#### 7.3 Функция состоит из двух вещей: / A function is made of: ####

* Инструкции для ЦП / Instructions for CPU
* Локальных данных: переменных / Local data: the variables

---

> Now that we know how to represent data, let's start talking about a program's structure. A program's structure, is a set of functions. What we call a function, is an entity said to be closed because data in this entity are supposed to be closed to the rest of the world, which get this information, which we call parameters, and which will return a result, and between the two we have a process, and we'll see how it works. A function is always made of two things: instructions, and local variables.

## 8. Первые синтаксические элементы / First syntactic elements ##

#### 8.1 - Объявление функции / Function declaration ####

Здесь вы видите первый синтаксический элемент: объявление функции.

```c
type  name(type1 param1, type2 param2, ...)
BLOCK
```

Функция может быть объявлена довольно просто. Мы определяем ее тип `type`, т.е. тип того, что возвращает функция, потому что функция принимает такие значения, как входные, которые мы называем параметры, и возвращаем результат. Таким образом, тип, который вы видите первым в этом прототипе, является типом возвращаемого значения.

Затем у нас идет имя функции `name( )`, а потом список параметров (внутри скобок), которые каждый раз являются, типом 1-го параметра, названием 1-го параметра, типом 2-го параметра, названием 2-го параметра, и т.д., и т.д... Может быть столько параметров, сколько мы захотим, также их вообще может и не быть. Если параметры отсутствуют, мы просто пишем открывающие скобки `(`, закрывающие скобки `)`. Все это является тем, что возвращает функция, какие параметры она принимает, и после этого идет то, что у нас называется `Block` (блок).

#### 8.2 - Block: ####

```c
{
  local variables declaratin // объявление локальных переменных

  instructions // инструкции
}
```

Блок содержит саму функцию. Функция всегда разделена на две части и вторая часть (блок) находится между фигурными скобками `{}`. Итак, у нас есть открывающаяся фигурная скобка `{`, потом объявление локальных переменных, после которой следуют инструкции. У нас может быть только одна инструкция, может и не быть локальных переменных, может и не быть инструкций, и мы всегда заканчиваем закрывающей фигурной скобкой `}`.

---

> Here, you see the first syntax element : the declaration of a function. A function can be declared rather simply. We define its type, meaning the type of what the function returns, because a function takes values as entries which we call parameters, and returns a result. So the type you see first on this prototype, is the return value's type. Then we have the function's name, and then the list of parameters, which are every time, the type of the 1st parameter, the name of the 1st parameter, the type of the 2nd parameter, the name of the 2nd parameter, etc, etc... There can be as many parameters as we want, there can also be none at all. If there's no parameter, we simply write opening parenthesis, closing parenthesis. That is what defines what the function returns, and what it takes for parameters, and right after, there's what we call a block. A block contains the function itself. A function is always split into two parts. The second part, the block, is between curly brackets. So there's an opening curly bracket, the declaration of local variables, followed by instructions, - There could be only one instruction, there could be no local variable, there could be no instruction - and we always end with a closing curly bracket.

## 9. Первый пример / First example ##

#### Объявление функции "sum" / The "sum" function declaration ####

Вот краткий пример небольшой функции.

```c
int sum(int value1, int value2)
{
  int total;

  instructions
}
```

Здесь мы объявляем функцию `sum()`, которая возвращает `int`, и которая принимает 2 параметра: параметр `value1`, который имеет тип `int`, и 2-й параметр `value2`, который также имеет тип `int`. Потом пишется блок функции, то есть открывая фигурную скобку `{`.

`int total` - объявляем новый `int` с именем `total`, который является локальной переменной функции. Функция является закрытой, что означает, что снаружи этой функции, эта переменная не существует, поэтому она локальна (local).

Затем у нас идут инструкции, в этом примере их нет, но по сути они всегда находятся там. И, наконец, закрывающаяся фигурная скобка `}`: конец блока, конец функции.

---

> Here's a quick example of a small function. Here we'll declare a function called sum(), which returns an int, and which takes 2 parameters: a parameter "value1", which is of type int, and a 2nd parameter "value2", which is also an int. This function starts it block, so opening curly bracket. "int total" declares a new int called "total", and is a local variable to the function. The functions are closed, which means outside of the function, this variable doesn't exist. Therefore, it's local. Then we've got the instructions In this example, there aren't any, but that's where they'd be. And finally, the closing curly bracket: end of the block, end of the function.

## 10. Составные (сложные) типы / Compound types ##

В Си мы можем объявлять, то что мы обычно называем комбинированные типы. Это структуры данных, которые сделаны из элементарных типов, которые мы видели ранее. Их несколько, но во время этого бассейна, мы будем использовать только пару типов. Первым является массив (array).

#### 10.1 - Массивы / Arrays ####

```c
type  name[numeric_value];     int tab[42];
```

Массив - это последовательность объектов одного типа (в памяти). Они легко объявляются: тип, имя, открывающаяся квадратная скобка `{`, количество элементов в массиве, закрывающаяся квадратная скобка `}`.

Справа у вас есть пример: `int tab[42]` - это объявление массива, который может содержать 42 элемента типа int. Индекс массива начинается с 0 до 41. Мы всегда начинаем с 0. Итак, с этим массивом вы зарезервировали в памяти 42 элемента типа int. Чтобы получить к ним доступ, мы пишем имя, открываем квадратную скобку `[`, номер нужного нам элемента типа int, и закрываем квадратной скобкой `]`. Например, если мы напишем `int tab[12]`, то получим 13-ый int элемент массива.

#### 10.2 - Структуры / Structures ####

```c
struct  struct_name           struct s_fortytwo
{                             {
  type  name;                   int   a;
  type  name;                   char  b[21];
};                            };
```

Второй комбинированный тип чуть сложнее (мы будем использовать его позже) и он называется структура данных. Структура позволит нам определить представление объекта в памяти, который будет состоять из базовых элементов, которые также могут быть структурами. Вы должны знать, что мы можем связывать структуры, массивы и т.д.

Давайте посмотрим, как объявить структуру: мы пишем `struct <имя_структуры>`, открываем фигурную скобку `{`, далее объявляем компоненты этой структуры (тип, имя и т.д.), закрываем фигурную скобку `}` и точку с запятой `;`. Тут, мы только что объявили структуру.

Справа есть пример, где мы объявляем структуру `s_fortytwo`. Он состоит из `int` с именем `a` и массива из 21 символа с именем `b`. Мы объявляем это простым способом, указанным ниже.

#### 10.3 - Объявление / Declaration ####

```c
struct  struct_name name;       struct  s_fortytwo a;
```

Мы объявляем структуру, и когда мы пишем `struct`, имя структуры, имя переменной, точка с запятой, то резервируется необходимую область памяти, и когда мы используем это имя, программа будет знать, что мы говорим о структуре.

---

> In C, we can declare what we call combined types. They're data structures which are made of elementary types, which we saw earlier on. There are a few, but during this piscine, we'll only use 2. The first is the array. An array is a succession of objects of the same type (in the memory). It's easily declared: type, name, opening square bracket, number of elements in the array, closing square bracket. You've got an example on the right : "int tab[42]", which is the declaration of an array, which can contain 42 ints. The array's index goes from 0 to 41. We always start at 0. So, with this array, you've reserved 42 ints in the memory. To access them, we write the name, opening square bracket, the number of the int we want, closing square bracket. For example, if we write "int tab[12]", we'll get the 13th int. The second combined type is a bit more complex, and we'll use it later on, is called data structure. The structure will allow us to define the representation of an object in memory, which will be made of basic elements, that could very well be structures too. You have to know we can interlink structures, arrays, etc... Let's check out how to declare a structure. we write "struct", the name of our structure, opening curly bracket, we declare this structure's components (type, name, etc...) closing curly bracket and semi-colon. Here, we've just declared a structure. There's an example on the right, where we declare a structure "s_fortytwo". It's made of an int called "a", and an array of 21 characters, called "b". We define it in a simple manner, indicated below. We declare the structure, and when we write "struct", name of the structure, name of the variable, semi-colon, it reserves the necessary memory area, and when we use this name, the program will know we're talking about a structure.

## 11. The Norm ##

Компилятор в Си довольно гибок, с точки зрения синтаксиса. Вы можете писать какие-либо вещи разными способами. Но чтобы сделать вещи более читабельными и иметь некоторую последовательность, мы установили стандарт (Norm). Этот стандарт мы представим вам позже. У вас будет отдельный урок на эту тему. Вам важно понять, что использование этого стандарта имеет множество преимуществ:

1. Первое преимущество заключается в том, что вам будет легче читать код и наоборот.
2. Второе преимущество в том, что это поможет вам научиться структурированно программировать. Вы увидите, что даже если вы до этого уже занимались программированием, то школьный стандарт все равно будет являться, своего рода, адаптацией.
3. Третье, большое преимущество в том, что она придает "внешний вид" и улучшает ваш скилл чтения чужого кода. Когда мы будем читать чужой код, то использование стандарта, при написании, позволит нам читать этот его быстрее.

Мы просим вас соблюдать стандарт, у нас также есть программа, которая проверяет соблюдение этого стандарта.

---

> The compiler in C is usually pretty permissive. In terms of syntax, you can write things in many different ways. But to make things more readable, and have some sort of consistency, we've defined a standard (Norm). This standard will be presented later on. You'll have a specific lesson on this topic. It's important for you to understand that using this standard has a lot of advantages. The 1st advantage is that it allows you to easily read each others code. The 2nd is that it helps learn how to program in a structured way. You'll see that even if you've already programmed before, the school's standard will still be an adjustment. > It's biggest advantage is that it gives us a "look and feel" and helps for the reading. When we'll read someone else's code, being used to a standard will allow us to read faster. We please respect it. We have a program that checks whether the standard's been respected.

## 12. Отправная точка / Entry point ##

#### 12.1 - Откуда начать? / Where to start from? ####

Мы видели, что программа представляет собой набор функций, и что их может быть много. Так откуда начать?

#### 12.2 - Обязательная функция с определенным названием : `main` / A mandatory function with a specific name ####

Было взято за основу, что в синтаксисе языка Си изначально, функцией, которая будет выполняться первой, будет функция `main()`, которая инициирует выполнение программы.

#### 12.3 - Где-то в вашем коде должно быть: / Somewhere in your code, there must be: ####

```c
int main()
{

}
```

Так что, если вы создадите программу, то где-то в вашем коде, будет функция `main()`. Это функция, которая принимает определенное количество параметров, позже вы увидите, как они работают и как их использовать. `main()` возвращает `int`, вы также увидите, как все это работает. Таким образом, у нас будет систематическое объявление `int main()`, потом параметры между круглыми скобками, если они есть и блок функции `{}`.

---

> We've seen that a program was a set of functions, and that there can be many functions. So where to start from? It has been defined, that in C syntax, originally, the function that will be executed first, the one that'll trigger the program's execution, is the function main().
> So if you create a program, somewhere in your code, there'll be a function main(). It's a function that takes a certain number of parameters, you'll see later how they work and how to use th main() returns an int, but you'll see how this also works. This way, you'll systematically have this declaration : "int main", the parameters between parenthesis, if there are any, and the function's block.

## 13. 3 вида инструкций / 3 kinds of instructions ##

Теперь, когда мы увидели общую структуру программы и увидели, как представлять данные, все что нам остается так это понять, как работают инструкции.

#### 13.1 - Blocks: ####

```c
{
  declarations; // объявления

  instructions; // инструкции
}
```

Конечно, зная уже, как объявлять данные, нам нужно научиться работать с этими данными. Это довольно просто. Есть 3 вида инструкций. Есть то, что мы называем "blocks" (блоки), которые, как мы видели, всегда состоят из открывающейся фигурной скобки `{`, объявлении локальных переменных для этого блока (локальных по отношению к блоку), и инструкций, которые будут выполняться этим блоком, и закрывающаяся фигурная скобка `}`.

#### 13.2 - Выражения: / Expressions: ####

```c
expression; // выражение

// Выражение - это вычисление, которое всегда вычисляется в виде числового значения.
// An expression is a computation that always evaluates to a numerical value.
```

Есть также то, что мы называем "выражениями", за которым следует точка с запятой `;`, и выполняется численное вычисление или анализ. Позже мы к этому еще придем.

#### 13.3 - Управляющие структуры / Control structures ####

А затем, у нас есть то, что мы называем "управляющие структуры", которые позволяют нам контролировать выполнение серий инструкций внутри блока.

---

> Now that we've seen the general structure of a program, and we've seen how to represent data, all that remains is how instructions work. Of course, now that we know how to declare data, we need to learn how to act on these data. It's quite simple. There are 3 types of instructions. There's what we call "blocks", which, as we've seen, are always made of an opening curly bracket, a collection of local variable declarations (local to the block), instructions which will be executed by that block, and a closing curly bracket. There's also what we call "expressions", which will be followed by a semi-colon, and make a numerical calculation, or evaluation, happen. We'll go into this later on. And then, we have what we call "control structures", which allows to control the proceedings of a series of instructions, inside a block.

## 14. Выражения / Expressions ##

Начнем с выражений. Итак, выражения, как мы уже говорили, представляют собой набор вычислений, которые дают результаты.

#### 14.1 - Непосредственные числовые значения / Immediate numerical values ####

```txt
0     42    0x1A    010
```

Числовое значение является самым простым таким вычислением. Например, если вы напишите, тут 0 и 42, вы также можете написать номер в шестнадцатеричной системе (hex) - 0X1A, в восьмеричной (octal) - 010, и оно будет вычислено в своем собственном значении, это означает, что компилятор удостоверится, что оно соответствует результату.

#### 14.2 - Переменные / Variables ####

```c
a           // Пример: `int a;`
b[18]       // Пример: `char b[63];`
sft_var.a   // Пример со структурой
```

Второй тип выражений: переменные, как только мы переходим к переменным, когда мы их используем, то происходит вычисление непосредственно значения переменных. Если, например, у вас есть значение в `int a`, как в примере, то написание `a` будет стоить значению, которое находится в самом `a`.

То же самое для массива: если вы написали `b[18]`, то он будет искать 19-й элемент, находящийся в `b`.

В случае структуры, если у вас есть элемент структуры с названием `sft_var.a`, он будет искать элемент `a` в структуре `sft_var`. Таким образом, переменная вычисляется непосредственно по содержащемуся в ней значению.


#### 14.3 - Вызовы функций: / Function calls: ####

```c
sum(18, a)
```

Вызов функции - так мы обычно называем третий тип выражений. Мы пишем имя функции, параметры, которые мы передадим этой функции, компилятор вызовет эту функцию и произойдет вычисление возвращаемого значения этой функции. Мы видели, что функция принимает параметры ввода, выполняет процесс, который мы ее просим, и возвращает значение, и это значение будет задано вместо самой функции.

#### 14.4 - Вычисления: / Computations: `+ - * / % ()` ####

```c
1 + 3 – ( a * 42 + b[0]) / sum(21, 34 – b[10])
```

Внутри этого вычисления находится функция. Мы можем комбинировать все эти элементы благодаря вычислениям. Таким образом, компилятор будет обрабатывать всю арифметику, и, как вы видите ниже, мы можем писать довольна сложные вещи.

Если вы напишите `1 + 3`, то будет взята `1` и к ней добавят `3`. `-` и компилятор обрабатывает скобки и приоритетные операции. Есть `b[0]`, который получит первый элемент массива `b`. Когда мы пишем `a * 42`, то компилятор получит значение `a`. Потом он разделит на сумму 2 элементов, возвращаемую функцией `sum()`.

Компилятор произведет анализ, вычислит результат этих арифметических выражений и сделает он это в правильном порядке.

#### 14.5 - Присвоения: / Assignations: ####

```c
a = 42
b[2 + a] = sum(12, 30)
sft_var.a = 0
```

Последний тип выражений: присвоения. Присвоение, например, - это когда мы пишем `a = 42`. Компилятор присвоит значение `42` в переменную `a` и вернет, в результате, `42`. Мы систематически будем иметь присвоение и вычисление.

К примеру, если вы напишите `b[2 + a]`, то мы возьмем значение содержащееся в `a` и добавим к нему `2` и это значение будет служить индексом, чтобы по нему перейти к чтению в массиве `b`. Мы вычислим результат функции справа. Присвоим его элементу массива и вернем результат функции. Это является присвоением и оно изменило данные в самой переменной.

---

> Let's start with expressions. So, expressions, as we've said, are a set of evaluations, which will give results. The simplest of evaluations, is a numerical value.
> For example, if you wrote a number, here 0 and 42, you can write it in hex (0XA), in octal (010), and it'll evaluate itself to its own value meaning that the compiler will make sure it's worth its result.
> The 2nd type of expression: Variables, Once we've got a variable, when we use it, it'll go evaluate directly to the variable's value. If, for instance, you have a value in an int "a", like in the example, when you write "a", it'll be worth the value that's in "a".
> Same thing for an array : If you wrote b[18], it'll look for the 19th element, held in "b". In the case of a structure, if you have a structure element called "sft_var.a", it'll look for the element "a" in the structure "sft_var". So a variable is evaluated directly by the value it contains.
> The 3rd type of expression is what we call function calls. We write the name of the function, the parameters we'll pass to this function, the compiler will call the function, and it'll be evaluated to the function's return value. We've seen that a function takes parameters for entry, does the process we ask it to do, and returns a value. So this value will be set instead of the function.
> In the following calculation, we'll have a function. We can combine all these elements thanks to computations. This way, the compiler will process the arithmetics, and, as you can see below, we can write very complicated things. If you write "1 + 3" it'll take the 1, and add 3 to it, "-", it handles parenthesis and priorities, operations, there's a b[0] which will get the first element of the array "b", when it'll write "a x 42", it'll go get the value of "a", it'll divide by the sum of 2 elements, returned by the function sum(). The compiler will manage to evaluate, calculate, the result of these arithmetic expressions and will do it in the right order.
> The last type of expressions : Assignations. An assignation, is, for instance, when we write "a = 42". The compiler will set the value "42" to the variable "a", and will return, as a result, 42. We'll systematically have an assignation and an evaluation.
> For example, if you write "b[2 + a]", we'll go get the value contained in "a", and add 2 to it. This value serves as an index, to go read in the array "b". We'll calculate the result of the function that's on the right, we'll assign it in the array, and we'll return, as a result, the function's result. It's an assignation, and it'll modify the data in the variable.

## 15. Выражения (опять) / Expressions (again) ##

#### 15.1 - Операторы сравнения (компараторы): `== != < > <= >= || && !` / Comparisons: ####

```c
a < 2 + b[23]
a - 2 == 32 || b[11] + 3 >= 17
```

Есть и другие выражения. У нас есть то, что мы называем Операторы сравнения. Оператор сравнения в Си - это оператор, который, как и любое другое выражение, будет оценивать по значению. Мы называем `true` возвращаемое значение `1` и `false` возвращаемое значение `0`. Поэтому, например, когда вы пишите `a == b`, то будет произведена проверка равенства содержимого переменной `a` с содержимым переменной `b`. Если содержимое этих двух равно, то вернется `1`, если иначе (else) то вернется `0`.

Все операторы сравнения работают одинаково. Другой пример, если вы напишите `a < b`, то будет произведена проверка значения `a` по отношению к `b`, если `a` меньше `<` чем `b`, то вернется `1`, если иное значение, то вернется `0`.

В качестве операторов, у вас есть `==` - сравнение равенства, `!=`- неравенство (отличается от), `<` - меньше, `>` - больше, `<=` - меньше или равно, `>=` - больше или равно, `||` - или (логическое сложение), `&&` - и (логическое умножение), `!` - не (логическое отрицание).

Если мы напишем `!a`, то если в процессе сравнения, `a` будет `0` (false), то вернется 1, если будет иначе `true`, то вернется 0. Поэтому все это называется операторы сравнения.

#### 15.2 - Побитовые (бинарные) операторы `>> << | & ^` / Binary operators: ####

Также у нас есть то, что мы называем побитовые операторы. Эти операторы буду напрямую обрабатыват двоичные данные переменной. Позже, мы более подробно рассмотрим это, потому что пока нам это не пригодится, но они позволяют обрабатывать каждый бит содержащийся в параменных.

#### 15.3 - Составное присваивание (сокращения): / Shortcuts: ####

```c
a += 10     <=>    a = a + 10
b[50] /= 2  <=>    b[50] = b[50] / 2
a++         <=>    a += 1              <=>    a = a + 1
```

Затем, у нас есть составное присваивание (сокращение), которое позволяет облегчить чтение. Например, мы можем написать `a += 10` и это будет тоже самое, что если мы напишем `a = a + 10`. Мы можем написать `a++`, это будет аналогично написанию `a = a + 1`. Мы можем написать `/=` и это будет тоже самое, что и деление. Все это является просто средством для сокращения написания кода.

#### 15.4 - Особенности: / Specials: ####

```c
'A'   // dec #65 в таблице ASCII
sizeof(type_of_var)
&a    // адрес переменной в памяти ОЗУ
exp1 ? exp2 : exp3
```

Также существуют особенные элементы выражения. Например `'A'`: возвращает ASCII-код символа между между апострофами. на самом деле, ASCII-код для `A` - это 65. ASCII-коды очень важны, так как они позволяют нам отображать символы. Есть ASCII таблица, но мы к этому еще позже вернемся.

У нас есть оператор `sizeof`. Мы пишем `sizeof`, тип переменной, [размер (sizeof) непосредственно самой переменной], и он вернет нам размер, который эта переменная занимает в памяти.

Последнее: если мы добавим `&` перед переменной, то вернется адрес этой переменной в памяти.

У нас также есть тернарная условная операция, которую мы используем довольно редко, ее алгоритм следующий: выражение1, `?`, выражение2, `:`, выражение3, и оно производит анализ по выражению1.
Если выражение не является `null`, то оно вычислит выражение2 и вернет его в качестве значения. Если иначе (else), то оно вычислит выражение3 и вернет его, как значение. Поэтому, это условное выражение.

#### 15.5 - Символьные строки / Strings ####

```c
"hello forty-two"

/*
автоматически сохраняет последовательность ascii-кодов в массиве символов, который заканчивается на \0; производит вычисления по адресу первого символа.

automatically stores a sequence of ascii codes in a char array ended by 0; evaluates to the address of the first char.
*/
```

Последний пункт, это то, что мы называем символьными строками. Строка - это серия символов между кавычек, происходит выделение памяти для символов между этими самыми кавычками и в конце будет добавлен `\0` (терминирующий ноль) и он вернет адрес первого символа.

---

> There are other expressions. We have what we call comparisons. A comparison in C, is an operator which will be evaluated, just like any other expression, to a value. We call TRUE, the return value 1, and FALSE, the return value 0. So when you write, for instance, "a == b", it'll check if the content of variable "a" is equal to the content of variable "b". If both contents are equal, it'll return 1, else it'll return 0.
> All comparators work the same way. Another example, if you write "a < b", it'll check the values of "a" and "b", if "a" is indeed inferior to "b", it'll return 1, else it'll return 0. As operators, you have "==", which compares equality, "!=" means "different than", "<", ">", "<=", ">=", "||" (logical OR), "&&" (logical AND) and "!!" which is a negation. If we write "!a", if "a" is worth 0, then it return 1, else it returns 0. So these are comparison operators.
> We also have what we call binary operators. These operators will process the variable's binary data directly. We'll go into more details later on, because it's not very useful for now. But it allows to process each of the bits contained in variables.
> Then we have shortcuts, which allow to facilitate the reading. For instance we can write "a += 10", that's just like writing "a = a + 10". We could write "a++", which is the same as writing "a = a + 1". We can write "/=", that's the same as doing a division. Those are just means to simplify writing.
> There are some special expression elements. For example 'A' returns the ASCII code for the character between apostrophes. Actually, the ASCII code for "A" is 65. ASCII codes are extremely important, as they allow us to display characters. There's an ASCII table, but we'll get back to this later on.
> We have the operator SIZEOF. We write "sizeof", the type of variable, of directly a variable, and this will return the size this variable take up in the memory.
> A last one: if we add an "&" before a variable, it'll return the address of this variable, in the memory. There's what we call a ternary operator, even if we rarely use it. The syntax is as follows : and expression, "?",  a 2nd expression, ":", a 3rd expression, and it'll evaluate the fist expression.
> If the expression isn't NULL, it'll evaluate the second, and return it as a value. Or else, it'll evaluate the third expression, and return it as a value. So, it's a conditional expression.
> The last point, is what we call character strings. A string is a series of characters between inverted commas. This will allocate memory for the characters between inverted commas. It'll add a "\0" in the end, and it'll return the address of the first character.


## 16. Указатели / The pointers ##

#### 16.1 - Определение: / Definition: ####

```c
/*
указатель - это переменная, в которой хранится адрес области памяти другой переменной данного ею типа.

a pointer is a variable that stores the memory address of another variable of a given type
*/
```

Когда мы перечисляли типы, то видели один особенный тип - указатели. Указатель - это переменная, как и другие, только вместо хранения данных, она будет хранить адрес другой переменной, ну, или по крайней мере, адрес данных. По сути, это указатель на что-то, и следуя из его названия, он содержит адрес чего-то.

#### 16.2 - Объявление: / Declaration: ####

```c
type  *name;

/* Конкретный пример */

int  *p;    // p содержит адрес int переменной
            // p stores the address of an int variable.
```

Как объявить указатель? Сначала мы должны объявить тип того, на что мы указываем, имея в виду тип переменной, адрес которой мы хотим хранить. Итак, мы пишем тип, `*<имя_переменной>`. Например: если мы напишем `int *p`, то `p` будет хранить адрес переменной типа int.

#### 16.3 - Применение: / Use: ####

```c
int a;
int *p;

p = &a;    // *p = 1;   <=>   a = 1;
*p = 1;


/*
Если (p) содержит адрес (a), то (*p) - это другое имя области памяти (a); <*name> - это объект типа <type>, адрес которого содержится в <name>.

if p stores the address of a, then *p is another name for the memory area of a; <*name> is the object of type <type>, the address of which is stored in <name>.
*/
```

Как мы их используем? Довольно просто. Как только мы объявим указатель типа int, как это сделал я, далее мы пишем `p = &a`: установив в `p` адрес переменной `a`. Потом мы используем `*p`.

Написав `*p = 1;`, мы устанавливаем значение `1` внутрь адреса на который указывает `p`, это тоже самое, что если мы напишем `a = 1`, так как `p` содержит адрес `a`. Так что если `p` содержит адрес `a`, то `*p` - это тоже самое, что и `a`, это таже самая область памяти, тот же адрес и тот же тип.

В принципе, можно сказать, что `*<name>`, то есть `*`, имя переменной типа указателя - это объект типа `<type>`, чей адрес содержится в `<name>`. Это очень важно. Вы должны систематически ссылаться на это определение. Когда у меня есть указатель с именем `<name>`, типа `<type>`, то `*<name>` - это объект типа `<type>`, который хранится в `<name>`.

#### 16.4 - Арифметика указателей: / Pointers arithmetic: ####

```c
int tab[42];
int *p;

p = &(tab[0]);
*(p + x);
```

Итак, у нас еще есть арифметическая система. Давайте возьмем массив `tab[42]`. Итак `p`, объект типа указатель, который хранит адрес первого элемента `0` массива `tab[]`. Если мы напишем `*(p + x)`, то мы получим доступ к значению расположенному в позиции `x` нашего массива, это тоже самое, если бы написали `tab[x]`.

---

> We've seen, when we listed types, that there's a particular type... Pointers. A pointer is a variable like the others, except that instead of storing data, it'll store the address of another variable, well at least the data's address. It's a pointer to something, so, as it name suggests, it contains the address of something.
> How to declare a pointer? First we have to declare the type of what we point to, meaning the variable's type whose address we want to store. So we write the type, "\*", the name. An example : If I write "int \*p", "p" stores the address of a variable of type int. How do we use them? Quite simply. Once we've declared a pointer of type int, as I did just there. We write "p = &a". We'll set the address of "a" in "p". Then we'll use "*p".
> We do "p = 1;" it'll set "1" inside the address pointed by "p", It's the same as writing "a = 1", as "p" contains the address of "a". So if "p" contains the address of "a", "\*p" is the same thing as "a", It's the same memory area, the same address and the same type.
> Basically, we can say that "\*name" so "*" the name of a variable, of type pointer, is the object of type "type" whose addresses is stored in "name". That's very important. You must systematically refer to this definition. When I have a pointer called "name", of type "type", \*name is the object of type "type", stored in "name.
> So we have an arithmetics system. Let's take an array "tab[42]", So "p", an object of type pointer, which stores the address of tab's first element. If we write "*(p + x)", we access the value located at the position "x" of our array, same as if we wrote "tab[x]".

## 17. Управляющие конструкции / Control structures ##

Итак, до этого момента, мы видели объявление переменных, инструкции, и теперь нам осталось разобраться с управляющими конструкциями. Мы увидим 3 таких конструкции, вообще-то мы увидим 4, т.к. 2 из них очень похожи.

#### 17.1 The `if`: ####

```c
if (expression)
  instructions

if (expression)
  instructions

else
  instructions
```

Первая упр. конструкция - это условный оператор `if`. Все довольно просто: мы пишем `if (выражение)` а затем инструкцию. Эта инструкция может быть блоком, то есть содержать несколько инструкций и объявлений. Как это работает? Все просто: оно вычисляет выражение. Итак, мы собираемся вычислить результат выражения, если выражение возвращает 0, то ничего не происходит, если вернется что-то еще, кроме 0, то выполняется инструкция. Это, по сути, простая проверка и довольна практична в применении.

Есть более продуманный вариант такой конструкции, он выглядит примерно так: `if (выражение) {инструкции} else (другие инструкции). Если 1ое выражение имеет значение 0 (false), то происходит выполнение 2ого выражения. Если 1ое выражение имеет значение 1 (true), то происходит выполнение инструкций 1ого выражения. Все это довольно просто.

#### 17.2 The `while`: ####

```c
while (expression)
  instructions
```

Вторая упр. конструкция - это цикл `while` и он довольно прост: `while (выражение), и инструкция`. Сам процесс немного отличается. `while` вычисляет выражение является 0 (false), то цикл останавливается. Если является чем-то другим, нежели 0, то выполняются инструкции.

Выглядит это почти как `if`, за исключением того, что происходит цикл, вместо того, чтобы остановиться. Если выражение является - 0 (false), мы прекращаем выполнение, если иначе - 1 (true), то мы опять выполняем инструкции и возвращаемся к началу.

Следуя из названия цикла `while` (пока), мы выполняем инструкции пока выражение не будет являться - 0 (false). Именно так работают все циклы. Именно так вы будете их использовать во время этого Бассейна. Существуют также другие управляющие структуры, но вы будете использовать только эти.

#### 17.3 The `return`: ####

```c
return (expression);
return;
```

Последняя управляющая структура - `return`, которая позволяющая возвращать значения при выходе из функции. Как мы уже видели, функция может принимать входные параметры и возвращать значение на выходе. `return` позволяет нам вернуть это значение, `return( )` вычисляет выражение и останавливает работу функции. Это значит, что если после `return` есть другие инструкции, то они выполняться не будут и возвращаемое значение функции будет результатом этого выражения.

Есть другой тип `return` без возвращаемого значения, предназначенный для определенного типа функции, которого мы еще не видели, но мы увидим его позже. Это функции, которые не могут возвращать значения и имеют другой синтаксис.

По сути на этом урок по Си закончен, ну или по крайней мере он закончен на тех вещах, которые вам будут нужны на бассейне.

---

> So. Up till now, we've seen variable declarations, instructions, and now we're left with control structures. In C, there are several control structures. We'll see 3. Actually, we'll see 4. Because 2 of them are very much alike. The first is the control structure IF. It's quite simple : we write "if (expression)" and then, an instruction.
> This instruction can be a block, which means it can contain several instructions, and declarations. How does it work? It's simple : it evaluates the expression. So we're going to calculate the result of the expression. If the expression returns 0, it doesn't do anything. if it returns something else than 0, it'll execute the instruction. It's a simple test, and quite practical to use.
> There's a more elaborated version which is "if (expression){instruction} else {other instruction}" As you can imagine, it evaluates the expression. If the expression is worth 0, it executes the 2nd expression. If the expression is worth 1, it executes the 1st expression. It's a rather simple thing.
> Second control structure, the structure WHILE. The structure WHILE is quite simple : "while (expression), and an instruction. The process is a little different. The WHILE evaluates the expression. If the expression us worth 0, it stops. If it's worth something other than 0, we'll execute the instruction.
> So far, it's just like with an IF, except that instead of stopping here, we loop. Which means we re-evaluate the expression. If the expression is worth 0, we stop, else, we execute the instruction again, and we go back to the start.
> As it names suggests, we'll execute the instruction while the expression isn't worth 0. That's how all loops work. That's how you'll use them during this piscine. There are other control structures, but you'll just use these ones.
> The last control structure : The structure RETURN, which allows to return a value at the exit of a function. As we've seen, the function takes parameters as entries, and returns a value upon exit. RETURN allows us to return this value. return(_) calculates the expression, and stops the function.
> This means that if there are other instructions after this "return", they won't be executed. The function's return value will be the result of the expression.
> There's another type of RETURN without a return value, meant for a particular type of function we haven't seen yet, but you'll see that later. Those are functions that can't return values, and which have a different syntax. That's it for this lesson about C, or at least for what you need for this Piscine.
