1
00:00:05,468 --> 00:00:10,298
Hello everyone, and welcome to this lesson : C in 42 minutes (almost)

2
00:00:11,378 --> 00:00:14,848
Before anything, small clarification : this lesson is not meant

3
00:00:14,848 --> 00:00:16,724
to teach you how to program in C.

4
00:00:17,234 --> 00:00:19,724
It's not an exhaustive description of the language.

5
00:00:19,724 --> 00:00:22,734
Its sole purpose is to bring forward

6
00:00:22,734 --> 00:00:25,153
elements you'll need to complete this piscine.

7
00:00:25,153 --> 00:00:29,483
It's a subset of C, which will allow you

8
00:00:29,483 --> 00:00:32,693
to accomplish everything that's asked of you during this piscine.

9
00:00:32,823 --> 00:00:37,003
Before even starting to write code,

10
00:00:37,123 --> 00:00:39,563
the 1st thing you need to understand is...

11
00:00:39,563 --> 00:00:41,793
What's a computer? What's in it?

12
00:00:41,793 --> 00:00:42,933
And how does it work?

13
00:00:42,933 --> 00:00:45,743
So, a machine is made of 3 elements.

14
00:00:46,273 --> 00:00:48,533
The first is the CPU.

15
00:00:48,533 --> 00:00:51,903
It's the one that processes all calculations, all comparisons, ...

16
00:00:51,923 --> 00:00:54,423
All of these actions are made by the CPU.

17
00:00:54,943 --> 00:00:56,763
The second element is the RAM.

18
00:00:56,763 --> 00:01:00,653
The RAM is a tool, an object that'll hold

19
00:01:00,663 --> 00:01:03,493
everything that's been memorised by the computer.

20
00:01:03,493 --> 00:01:05,453
So this second element is very important.

21
00:01:05,453 --> 00:01:08,563
And last, the 3rd element is made of computer peripherals/devices.

22
00:01:08,563 --> 00:01:12,253
That's what will allow you to connect your computer to the rest of the world.

23
00:01:12,643 --> 00:01:15,143
So we have those 3 elements.

24
00:01:15,143 --> 00:01:18,543
These 3 elements are interlinked by a system, called BUS

25
00:01:18,543 --> 00:01:21,113
which will allow information to be transferred.

26
00:01:21,363 --> 00:01:25,403
There's also a clock system,  which allows all of this to operate together.

27
00:01:27,450 --> 00:01:30,030
So, of course a computer is much more

28
00:01:30,030 --> 00:01:31,620
complex than what I've described.

29
00:01:31,620 --> 00:01:35,290
But that's, I would say, the image.

30
00:01:35,290 --> 00:01:38,300
or at least the representation we'll need

31
00:01:38,300 --> 00:01:41,290
during the rest of this piscine,

32
00:01:41,320 --> 00:01:44,400
and also, for a while, during 1st year at the school.

33
00:01:44,852 --> 00:01:47,622
So let's keep this basic description for now.

34
00:01:47,622 --> 00:01:48,952
I'll say it again:

35
00:01:49,010 --> 00:01:52,840
a processor (CPU), so a treatment unit, a memorisation system,

36
00:01:52,840 --> 00:01:56,360
which we call RAM, and a system of interface with the rest of the world

37
00:01:56,360 --> 00:01:58,970
in other words, devices.

38
00:01:59,778 --> 00:02:01,568
And programming, what does it mean?

39
00:02:01,618 --> 00:02:04,588
Programming, in the end, compared to what we've seen before,

40
00:02:04,648 --> 00:02:07,888
meaning the paradigm of the computer's description,

41
00:02:07,888 --> 00:02:11,248
consists in giving instructions to the processor,

42
00:02:11,248 --> 00:02:14,628
meaning a list of elementary actions

43
00:02:14,848 --> 00:02:19,938
which will handle data.

44
00:02:20,268 --> 00:02:23,388
So we'll be able to do extremely simple actions.

45
00:02:23,788 --> 00:02:27,288
Like, for example, comparing two data,

46
00:02:27,308 --> 00:02:31,778
a simple operation such as an addition, a subtraction or a division.

47
00:02:32,158 --> 00:02:36,328
We'll be able to relay an information in a new address,

48
00:02:36,368 --> 00:02:39,598
so, we'll be able to copy the data of an address into another.

49
00:02:39,868 --> 00:02:42,808
We'll be able to do basic arithmetics,

50
00:02:42,928 --> 00:02:46,878
basic comparisons, and we'll be able to

51
00:02:46,878 --> 00:02:50,098
send these data to a device, for example, display them onscreen,

52
00:02:50,098 --> 00:02:52,418
or simply forward them.

53
00:02:52,589 --> 00:02:55,609
What you need to understand, is that we're trying to do things

54
00:02:55,609 --> 00:02:59,499
that are extremely elementary, but that will be done extremely fast

55
00:02:59,499 --> 00:03:02,819
and in a very large quantity.

56
00:03:02,819 --> 00:03:08,009
These elementary instructions will allow us to simulate extremely

57
00:03:08,009 --> 00:03:12,269
complicated behaviors, maybe even

58
00:03:12,269 --> 00:03:13,459
simulate intelligence.

59
00:03:13,939 --> 00:03:16,859
However, today, our programming sytem

60
00:03:16,859 --> 00:03:20,079
won't be able to just do extremely elementary things.

61
00:03:21,175 --> 00:03:23,555
So what about C in all that?

62
00:03:23,875 --> 00:03:29,595
In the end, the computer will process a language, which is called

63
00:03:29,595 --> 00:03:32,335
computer-language, which is a very elementary language,

64
00:03:32,335 --> 00:03:35,665
directly made of codes that are particularly unpleasant

65
00:03:35,665 --> 00:03:37,115
for human beings.

66
00:03:37,115 --> 00:03:39,425
The C language is a layer above of this.

67
00:03:39,425 --> 00:03:43,765
It's a relatively simple language, that's close to

68
00:03:43,765 --> 00:03:44,995
the computer's language.

69
00:03:44,995 --> 00:03:48,525
Here, we'll have a sequential language which will, overall,

70
00:03:48,535 --> 00:03:52,925
have a translation in rather elementary operations.

71
00:03:52,940 --> 00:03:54,940
So nothing too complicated.

72
00:03:54,986 --> 00:03:58,396
However, it'll be readable and pretty simple to use

73
00:03:58,396 --> 00:03:59,756
by a human being.

74
00:03:59,832 --> 00:04:03,762
which will make this process efficient.

75
00:04:03,762 --> 00:04:06,042
So, we have a system that will be complicated,

76
00:04:06,042 --> 00:04:08,942
meaning we'll transform the C language into something we write

77
00:04:08,942 --> 00:04:10,352
in computer language.

78
00:04:10,652 --> 00:04:13,682
Then, this computer language will be executed by the processor,

79
00:04:13,712 --> 00:04:16,442
and it'll be readable by human beings,

80
00:04:16,442 --> 00:04:22,432
and it'll compile (so it's particularly efficient) all by letting a set of

81
00:04:22,442 --> 00:04:26,512
functionalities, that are relatively evolved, allowing us to

82
00:04:26,512 --> 00:04:28,212
function correctly.

83
00:04:28,482 --> 00:04:31,492
Another important layer to integrate,

84
00:04:31,752 --> 00:04:33,472
is the operating system.

85
00:04:33,472 --> 00:04:36,172
The operating system is the software

86
00:04:36,172 --> 00:04:37,782
that'll make the computer work.

87
00:04:38,182 --> 00:04:41,052
It'll be launched at the start-up, and will allow us

88
00:04:41,052 --> 00:04:44,672
to have an interface between the user and the machine.

89
00:04:45,252 --> 00:04:47,492
The OS,

90
00:04:47,492 --> 00:04:50,482
we'll see more complex definitions and descriptions later on,

91
00:04:50,482 --> 00:04:54,192
because it's a very complex object that's been elaborated with a lot

92
00:04:54,672 --> 00:04:56,872
of work for a very long time,

93
00:04:56,942 --> 00:04:59,102
The OS is the result of a strong evolution.

94
00:04:59,252 --> 00:05:03,762
This object will manage the entire functioning of the computer

95
00:05:03,762 --> 00:05:08,202
and your program will 'interface" itself with the OS.

96
00:05:08,202 --> 00:05:12,302
To be clear, when, for example, you'll want to display a character,

97
00:05:12,302 --> 00:05:17,222
your program, written in C, will tells the OS

98
00:05:17,222 --> 00:05:21,202
via what we call system-calls,

99
00:05:21,202 --> 00:05:24,062
"I want this character to be displayed"

100
00:05:24,062 --> 00:05:27,142
And it's the OS that'll do the job.

101
00:05:27,142 --> 00:05:30,062
Which means, in your program, you don't need to code

102
00:05:30,062 --> 00:05:32,452
the entire system, that'll lead

103
00:05:32,452 --> 00:05:34,102
to displaying a character.

104
00:05:34,102 --> 00:05:37,763
So, C will allow your to write simple instructions,

105
00:05:38,193 --> 00:05:41,673
which will allow you to "interface" with the OS, which will also

106
00:05:41,673 --> 00:05:45,322
"interface" itself with the hardware

107
00:05:45,322 --> 00:05:47,652
to display or to cary out the actions you need.

108
00:05:48,322 --> 00:05:54,397
As we've seen previously, the computer holds memory,

109
00:05:54,397 --> 00:05:58,117
so it holds data, and will be able

110
00:05:58,117 --> 00:06:01,217
to run processes on these data, so follow instructions.

111
00:06:01,304 --> 00:06:06,944
A C program, is the representation of not only data we'll process,

112
00:06:06,944 --> 00:06:10,738
which means we'll have information about these data,

113
00:06:11,028 --> 00:06:14,378
but also instructions.

114
00:06:14,423 --> 00:06:19,563
In the RAM, we'll depict the data by groups of 8,

115
00:06:19,674 --> 00:06:22,234
which we call bytes.

116
00:06:22,410 --> 00:06:27,130
It's a group of 8 bits, so 8, 1 and 0, we'll call that a byte.

117
00:06:27,130 --> 00:06:30,460
It allows us to represent numbers from 0 to 255,

118
00:06:31,820 --> 00:06:33,550
depending on their representation.

119
00:06:34,161 --> 00:06:37,131
and each of these bytes, will be given an address,

120
00:06:37,134 --> 00:06:39,944
which will allow us to recognise it, and find it.

121
00:06:40,557 --> 00:06:44,207
C will allow us to work on these bytes,

122
00:06:44,310 --> 00:06:46,710
and so work on the address system.

123
00:06:47,978 --> 00:06:53,026
C uses types to represent data,

124
00:06:53,026 --> 00:06:55,463
and so we'll have several types.

125
00:06:55,463 --> 00:06:58,773
The first type, is what we call CHAR,

126
00:06:58,840 --> 00:07:02,720
which is 8-bit, so a byte.

127
00:07:03,076 --> 00:07:09,216
So it can represent numbers from -128 to +127,

128
00:07:09,586 --> 00:07:12,956
and a basic arithmetics is affected to it,

129
00:07:12,956 --> 00:07:15,766
which will allow it to handles all usual processes:

130
00:07:15,766 --> 00:07:17,296
divisions, subtractions, etc...

131
00:07:17,296 --> 00:07:19,530
The second type is the UNSIGNED CHAR,

132
00:07:19,583 --> 00:07:24,393
which is also 8 bits, but that'll have another representation,

133
00:07:24,393 --> 00:07:27,263
which will go from 0 to 255.

134
00:07:28,133 --> 00:07:31,773
Then, you have what we call a SHORT, which is 2 bytes,

135
00:07:31,773 --> 00:07:35,343
out of 16-bits, which will allow us to represent

136
00:07:35,343 --> 00:07:40,238
from - 32 000 up to +32 000.

137
00:07:40,520 --> 00:07:44,285
You also have the UNSIGNED SHORT, skipping details...

138
00:07:44,315 --> 00:07:46,725
You have the INT, which is on 4 bytes,

139
00:07:46,725 --> 00:07:50,725
and it generally is the data structure

140
00:07:50,744 --> 00:07:53,994
we use the most, because it

141
00:07:53,994 --> 00:07:56,084
allows us to do most processes.

142
00:07:56,204 --> 00:07:58,014
You also have the UNSIGNED INT,

143
00:07:58,014 --> 00:08:01,054
the LONG, and the LONG LONG,

144
00:08:01,054 --> 00:08:03,436
which allow us to represent data

145
00:08:03,436 --> 00:08:04,786
up to 64 bits.

146
00:08:05,656 --> 00:08:07,646
You have the UNSIGNED LONG...

147
00:08:07,646 --> 00:08:11,026
And you have the last type, which is called the "star", "asterisk"

148
00:08:11,673 --> 00:08:15,093
or "pointer", which allows to hold

149
00:08:15,093 --> 00:08:19,093
not just a data, but the address of a data.

150
00:08:19,093 --> 00:08:22,433
We can consider that a data's address is also a data itself,

151
00:08:22,433 --> 00:08:25,503
but there's a special arithmetic that we'll see later on.

152
00:08:25,613 --> 00:08:27,883
Now that we know how to represent data,

153
00:08:27,883 --> 00:08:30,513
let's start talking about a program's structure.

154
00:08:30,513 --> 00:08:33,331
A program's structure, is a set of functions.

155
00:08:33,681 --> 00:08:36,182
What we call a function,

156
00:08:36,182 --> 00:08:39,492
is an entity said to be closed because

157
00:08:39,492 --> 00:08:41,602
data in this entity

158
00:08:41,602 --> 00:08:43,580
are supposed to be closed

159
00:08:43,580 --> 00:08:47,400
to the rest of the world, which get this information,

160
00:08:47,927 --> 00:08:50,257
which we call parameters, and which

161
00:08:50,257 --> 00:08:52,487
will return a result, and between the two

162
00:08:52,487 --> 00:08:55,037
we have a process, and we'll see how it works.

163
00:08:55,037 --> 00:08:57,195
A function is always made of

164
00:08:57,195 --> 00:09:01,195
two things: instructions, and local variables.

165
00:09:02,042 --> 00:09:05,002
Here, you see the first syntax element :

166
00:09:05,002 --> 00:09:06,602
the declaration of a function.

167
00:09:06,602 --> 00:09:09,382
A function can be declared rather simply.

168
00:09:09,382 --> 00:09:16,112
We define its type, meaning the type of what the function returns,

169
00:09:16,112 --> 00:09:18,372
because a function takes values as entries

170
00:09:18,372 --> 00:09:21,402
which we call parameters, and returns a result.

171
00:09:21,602 --> 00:09:26,722
So the type you see first on this prototype,

172
00:09:26,722 --> 00:09:29,572
is the return value's type.

173
00:09:29,932 --> 00:09:31,762
Then we have the function's name,

174
00:09:35,155 --> 00:09:37,685
and then the list of parameters, which are

175
00:09:37,685 --> 00:09:40,005
every time, the type of the 1st parameter,

176
00:09:40,005 --> 00:09:42,105
the name of the 1st parameter,

177
00:09:42,120 --> 00:09:43,980
the type of the 2nd parameter,

178
00:09:43,985 --> 00:09:45,775
the name of the 2nd parameter,

179
00:09:45,819 --> 00:09:47,489
etc, etc...

180
00:09:48,094 --> 00:09:50,434
There can be as many parameters as we want,

181
00:09:50,434 --> 00:09:52,194
there can also be none at all.

182
00:09:52,194 --> 00:09:54,416
If there's no parameter, we simply write

183
00:09:54,416 --> 00:09:56,416
opening parenthesis, closing parenthesis.

184
00:09:56,416 --> 00:09:59,046
That is what defines what the function returns,

185
00:09:59,046 --> 00:10:02,276
and what it takes for parameters, and right after,

186
00:10:02,276 --> 00:10:04,259
there's what we call a block.

187
00:10:04,779 --> 00:10:08,009
A block contains the function itself.

188
00:10:08,009 --> 00:10:11,143
A function is always split into two parts.

189
00:10:11,143 --> 00:10:15,433
The second part, the block, is between curly brackets.

190
00:10:15,433 --> 00:10:18,943
So there's an opening curly bracket, the declaration of local variables,

191
00:10:18,943 --> 00:10:21,943
followed by instructions,

192
00:10:21,943 --> 00:10:25,343
- There could be only one instruction, there could be no local variable,

193
00:10:25,343 --> 00:10:29,873
there could be no instruction -

194
00:10:29,873 --> 00:10:33,263
and we always end with a closing curly bracket.

195
00:10:33,732 --> 00:10:35,432
Here's a quick example

196
00:10:35,432 --> 00:10:40,262
of a small function. Here we'll declare

197
00:10:40,262 --> 00:10:43,882
a function called sum(), which returns an int,

198
00:10:43,882 --> 00:10:47,882
and which takes 2 parameters:

199
00:10:47,968 --> 00:10:51,968
a parameter "value1", which is of type int,

200
00:10:51,997 --> 00:10:55,837
and a 2nd parameter "value2", which is also an int.

201
00:10:55,847 --> 00:11:01,847
This function starts it block, so opening curly bracket.

202
00:11:02,497 --> 00:11:06,187
"int total" declares a new int called "total",

203
00:11:06,187 --> 00:11:08,267
and is a local variable to the function.

204
00:11:08,287 --> 00:11:11,087
The functions are closed,

205
00:11:11,087 --> 00:11:15,317
which means outside of the function, this variable doesn't exist.

206
00:11:15,317 --> 00:11:17,477
Therefore, it's local.

207
00:11:18,084 --> 00:11:19,564
Then we've got the instructions

208
00:11:19,564 --> 00:11:22,904
In this example, there aren't any, but that's where they'd be.

209
00:11:22,904 --> 00:11:26,574
And finally, the closing curly bracket: end of the block, end of the function.

210
00:11:27,103 --> 00:11:30,103
In C, we can declare what we call combined types.

211
00:11:30,103 --> 00:11:33,863
They're data structures which are made of

212
00:11:33,863 --> 00:11:36,113
elementary types, which we saw earlier on.

213
00:11:36,146 --> 00:11:40,466
There are a few, but during this piscine,

214
00:11:40,466 --> 00:11:44,596
we'll only use 2.

215
00:11:45,476 --> 00:11:47,116
The first is the array.

216
00:11:47,116 --> 00:11:51,176
An array is a succession of objects

217
00:11:51,176 --> 00:11:56,366
of the same type (in the memory).

218
00:11:56,766 --> 00:12:00,637
It's easily declared: type, name,

219
00:12:00,637 --> 00:12:04,577
opening square bracket, number of elements in the array,

220
00:12:04,577 --> 00:12:06,017
closing square bracket.

221
00:12:06,622 --> 00:12:09,542
You've got an example on the right :

222
00:12:09,542 --> 00:12:14,672
"int tab[42]", which is the declaration of an array,

223
00:12:14,672 --> 00:12:16,550
which can contain 42 ints.

224
00:12:16,550 --> 00:12:21,460
The array's index goes from 0 to 41.

225
00:12:22,210 --> 00:12:23,210
We always start at 0.

226
00:12:23,210 --> 00:12:25,612
So, with this array,

227
00:12:25,612 --> 00:12:28,612
you've reserved 42 ints in the memory.

228
00:12:29,641 --> 00:12:33,311
To access them, we write the name, opening square bracket,

229
00:12:33,311 --> 00:12:37,481
the number of the int we want, closing square bracket.

230
00:12:37,481 --> 00:12:42,508
For example, if we write "int tab[12]", we'll get the 13th int.

231
00:12:43,598 --> 00:12:48,622
The second combined type is a bit more complex,

232
00:12:48,622 --> 00:12:51,622
and we'll use it later on, is called data structure.

233
00:12:51,622 --> 00:12:56,522
The structure will allow us to define the representation of an object in memory,

234
00:12:57,401 --> 00:13:00,791
which will be made of basic elements, that could very well be

235
00:13:00,791 --> 00:13:02,071
structures too.

236
00:13:02,071 --> 00:13:05,421
You have to know we can interlink structures, arrays, etc...

237
00:13:05,611 --> 00:13:08,303
Let's check out how to declare a structure.

238
00:13:08,303 --> 00:13:12,843
we write "struct", the name of our structure, opening curly bracket,

239
00:13:12,843 --> 00:13:18,923
we declare this structure's components (type, name, etc...)

240
00:13:20,343 --> 00:13:22,176
closing curly bracket and semi-colon.

241
00:13:22,176 --> 00:13:24,526
Here, we've just declared a structure.

242
00:13:24,921 --> 00:13:27,151
There's an example on the right,

243
00:13:27,151 --> 00:13:31,921
where we declare a structure "s_fortytwo".

244
00:13:33,667 --> 00:13:36,252
It's made of an int called "a",

245
00:13:36,252 --> 00:13:40,142
and an array of 21 characters,

246
00:13:40,142 --> 00:13:41,482
called "b".

247
00:13:42,598 --> 00:13:46,198
We define it in a simple manner, indicated below.

248
00:13:46,198 --> 00:13:47,618
We declare the structure,

249
00:13:47,688 --> 00:13:52,058
and when we write "struct", name of the structure,

250
00:13:52,058 --> 00:13:56,008
name of the variable, semi-colon, it reserves the necessary memory area,

251
00:13:56,330 --> 00:13:58,748
and when we use this name, the program will know

252
00:13:58,748 --> 00:14:00,448
we're talking about a structure.

253
00:14:00,448 --> 00:14:03,638
The compiler in C is usually pretty permissive.

254
00:14:04,128 --> 00:14:06,458
In terms of syntax, you can write things

255
00:14:06,458 --> 00:14:07,998
in many different ways.

256
00:14:07,998 --> 00:14:10,649
But to make things more readable,

257
00:14:10,780 --> 00:14:14,500
and have some sort of consistency,

258
00:14:14,790 --> 00:14:16,810
we've defined a standard (Norm).

259
00:14:17,220 --> 00:14:19,600
This standard will be presented later on.

260
00:14:19,600 --> 00:14:25,300
You'll have a specific lesson on this topic.

261
00:14:25,403 --> 00:14:28,393
It's important for you to understand that using this standard

262
00:14:28,393 --> 00:14:29,623
has a lot of advantages.

263
00:14:29,623 --> 00:14:32,480
The 1st advantage is that it allows you to easily read

264
00:14:32,480 --> 00:14:34,480
each others code.

265
00:14:34,480 --> 00:14:38,150
The 2nd is that it helps learn how to program

266
00:14:38,150 --> 00:14:39,626
in a structured way.

267
00:14:39,626 --> 00:14:43,166
You'll see that even if you've already programmed before,

268
00:14:43,166 --> 00:14:45,727
the school's standard will still be an adjustment.

269
00:14:46,347 --> 00:14:49,837
It's biggest advantage is that it gives us a

270
00:14:49,837 --> 00:14:52,311
"look and feel" and helps for the reading.

271
00:14:52,311 --> 00:14:54,531
When we'll read someone else's code,

272
00:14:54,531 --> 00:14:57,851
being used to a standard will allow us to read faster.

273
00:14:57,851 --> 00:14:59,961
We please respect it.

274
00:14:59,961 --> 00:15:03,151
We have a program that checks whether the standard's been respected.

275
00:15:03,203 --> 00:15:07,593
We've seen that a program was a set of functions,

276
00:15:07,593 --> 00:15:12,986
and that there can be many functions.

277
00:15:12,986 --> 00:15:15,206
So where to start from?

278
00:15:15,206 --> 00:15:17,556
It has been defined,

279
00:15:17,556 --> 00:15:20,258
that in C syntax, originally,

280
00:15:20,258 --> 00:15:24,758
the function that will be executed first, the one that'll trigger

281
00:15:24,758 --> 00:15:27,738
the program's execution, is the function main().

282
00:15:28,918 --> 00:15:31,271
So if you create a program,

283
00:15:31,271 --> 00:15:34,141
somewhere in your code, there'll be a function main().

284
00:15:34,455 --> 00:15:37,339
It's a function that takes a certain number of parameters,

285
00:15:37,339 --> 00:15:40,809
you'll see later how they work and how to use them.

286
00:15:41,244 --> 00:15:45,034
main() returns an int, but you'll see how this also works.

287
00:15:45,034 --> 00:15:47,967
This way, you'll systematically have this declaration :

288
00:15:47,967 --> 00:15:51,987
"int main", the parameters between parenthesis, if there are any,

289
00:15:51,987 --> 00:15:53,697
and the function's block.

290
00:15:54,201 --> 00:15:57,004
Now that we've seen the general structure of a program,

291
00:15:57,174 --> 00:15:59,454
and we've seen how to represent data,

292
00:15:59,454 --> 00:16:02,084
all that remains is how instructions work.

293
00:16:03,391 --> 00:16:06,391
Of course, now that we know how to declare data,

294
00:16:06,788 --> 00:16:09,548
we need to learn how to act on these data.

295
00:16:09,548 --> 00:16:12,098
It's quite simple.

296
00:16:12,098 --> 00:16:13,937
There are 3 types of instructions.

297
00:16:13,937 --> 00:16:18,257
There's what we call "blocks", which, as we've seen,

298
00:16:18,257 --> 00:16:21,587
are always made of an opening curly bracket,

299
00:16:21,617 --> 00:16:24,777
a collection of local variable declarations (local to the block),

300
00:16:24,777 --> 00:16:27,777
instructions which will be executed by that block,

301
00:16:27,777 --> 00:16:29,607
and a closing curly bracket.

302
00:16:30,771 --> 00:16:33,771
There's also what we call "expressions",

303
00:16:33,771 --> 00:16:38,801
which will be followed by a semi-colon,

304
00:16:39,046 --> 00:16:43,286
and make a numerical calculation, or evaluation, happen.

305
00:16:44,366 --> 00:16:46,690
We'll go into this later on.

306
00:16:46,690 --> 00:16:49,450
And then, we have what we call "control structures",

307
00:16:49,450 --> 00:16:53,030
which allows to control the proceedings

308
00:16:53,467 --> 00:16:55,887
of a series of instructions, inside a block.

309
00:16:56,786 --> 00:17:01,166
Let's start with expressions.

310
00:17:01,956 --> 00:17:03,744
So, expressions, as we've said,

311
00:17:03,744 --> 00:17:08,434
are a set of evaluations, which will give results.

312
00:17:08,564 --> 00:17:12,744
The simplest of evaluations, is a numerical value.

313
00:17:12,744 --> 00:17:17,774
For example, if you wrote a number, here 0 and 42,

314
00:17:17,774 --> 00:17:23,004
you can write it in hex (0XA), in octal (010),

315
00:17:24,044 --> 00:17:28,184
and it'll evaluate itself to its own value.

316
00:17:28,184 --> 00:17:32,154
meaning that the compiler will make sure it's worth its result.

317
00:17:32,154 --> 00:17:34,964
The 2nd type of expression: Variables,

318
00:17:35,082 --> 00:17:38,932
Once we've got a variable, when we use it,

319
00:17:38,932 --> 00:17:42,549
it'll go evaluate directly to the variable's value.

320
00:17:42,549 --> 00:17:46,159
If, for instance, you have a value in an int "a",

321
00:17:46,159 --> 00:17:47,929
like in the example,

322
00:17:47,929 --> 00:17:51,619
when you write "a", it'll be worth the value that's in "a".

323
00:17:52,596 --> 00:17:56,746
Same thing for an array : If you wrote b[18],

324
00:17:56,746 --> 00:18:00,579
it'll look for the 19th element,

325
00:18:00,579 --> 00:18:03,523
held in "b".

326
00:18:03,639 --> 00:18:07,499
In the case of a structure,

327
00:18:07,499 --> 00:18:11,970
if you have a structure element called "sft_var.a",

328
00:18:11,970 --> 00:18:16,709
it'll look for the element "a" in the structure "sft_var".

329
00:18:17,209 --> 00:18:21,060
So a variable is evaluated directly by the value it contains.

330
00:18:21,480 --> 00:18:25,121
The 3rd type of expression is what we call function calls.

331
00:18:25,121 --> 00:18:27,831
We write the name of the function,

332
00:18:27,831 --> 00:18:31,051
the parameters we'll pass to this function,

333
00:18:31,051 --> 00:18:33,831
the compiler will call the function,

334
00:18:33,831 --> 00:18:36,661
and it'll be evaluated to the function's return value.

335
00:18:36,661 --> 00:18:39,921
We've seen that a function takes parameters for entry,

336
00:18:39,921 --> 00:18:43,451
does the process we ask it to do, and returns a value.

337
00:18:43,451 --> 00:18:48,111
So this value will be set instead of the function.

338
00:18:48,381 --> 00:18:51,865
In the following calculation, we'll have a function.

339
00:18:51,865 --> 00:18:55,790
We can combine all these elements thanks to computations.

340
00:18:56,863 --> 00:19:00,100
This way, the compiler will process the arithmetics,

341
00:19:00,100 --> 00:19:02,450
and, as you can see below, we can write

342
00:19:02,450 --> 00:19:04,320
very complicated things.

343
00:19:04,533 --> 00:19:09,286
If you write "1 + 3" it'll take the 1, and add 3 to it,

344
00:19:09,356 --> 00:19:13,386
"-", it handles parenthesis and priorities, operations,

345
00:19:14,149 --> 00:19:19,939
there's a b[0] which will get the first element of the array "b",

346
00:19:19,986 --> 00:19:24,076
when it'll write "a x 42", it'll go get the value of "a",

347
00:19:24,510 --> 00:19:30,150
it'll divide by the sum of 2 elements, 

348
00:19:30,150 --> 00:19:35,300
returned by the function sum().

349
00:19:35,594 --> 00:19:39,194
The compiler will manage to evaluate, calculate,

350
00:19:39,194 --> 00:19:42,364
the result of these arithmetic expressions

351
00:19:42,364 --> 00:19:46,704
and will do it in the right order.

352
00:19:47,522 --> 00:19:50,182
The last type of expressions : Assignations.

353
00:19:51,233 --> 00:19:55,013
An assignation, is, for instance, when we write "a = 42".

354
00:19:55,013 --> 00:19:59,833
The compiler will set the value "42" to the variable "a",

355
00:19:59,833 --> 00:20:03,393
and will return, as a result, 42.

356
00:20:03,466 --> 00:20:08,036
We'll systematically have an assignation and an evaluation.

357
00:20:08,716 --> 00:20:13,220
For example, if you write "b[2 + a]",

358
00:20:14,368 --> 00:20:17,368
we'll go get the value contained in "a",

359
00:20:18,079 --> 00:20:21,079
and add 2 to it.

360
00:20:21,790 --> 00:20:24,790
This value serves as an index,

361
00:20:24,790 --> 00:20:27,079
to go read in the array "b".

362
00:20:27,772 --> 00:20:31,852
We'll calculate the result of the function that's on the right,

363
00:20:32,646 --> 00:20:35,656
we'll assign it in the array,

364
00:20:35,670 --> 00:20:39,760
and we'll return, as a result, the function's result.

365
00:20:40,904 --> 00:20:45,504
It's an assignation, and it'll modify the data in the variable.

366
00:20:46,514 --> 00:20:48,424
There are other expressions.

367
00:20:48,424 --> 00:20:51,424
We have what we call comparisons.

368
00:20:51,424 --> 00:20:56,924
A comparison in C, is an operator which will be evaluated,

369
00:20:56,944 --> 00:20:59,424
just like any other expression, to a value.

370
00:21:00,124 --> 00:21:05,864
We call TRUE, the return value 1,

371
00:21:05,864 --> 00:21:09,235
and FALSE, the return value 0.

372
00:21:09,235 --> 00:21:14,235
So when you write, for instance, "a == b",

373
00:21:15,215 --> 00:21:18,733
it'll check if the content of variable "a"

374
00:21:18,733 --> 00:21:21,193
is equal to the content of variable "b".

375
00:21:21,751 --> 00:21:26,741
If both contents are equal, it'll return 1, else it'll return 0.

376
00:21:27,781 --> 00:21:30,370
All comparators work the same way.

377
00:21:31,343 --> 00:21:34,343
Another example, if you write "a < b",

378
00:21:34,906 --> 00:21:40,586
it'll check the values of "a" and "b",

379
00:21:40,667 --> 00:21:45,469
if "a" is indeed inferior to "b", it'll return 1, else it'll return 0.

380
00:21:45,469 --> 00:21:49,557
As operators, you have "==", which compares equality,

381
00:21:49,557 --> 00:22:00,319
"!=" means "different than", "<", ">", "<=", ">=", "||" (logical OR),

382
00:22:00,319 --> 00:22:06,890
"&&" (logical AND) and "!!" which is a negation.

383
00:22:06,890 --> 00:22:11,732
If we write "!a", if "a" is worth 0, then it return 1,

384
00:22:12,644 --> 00:22:14,214
else it returns 0.

385
00:22:15,312 --> 00:22:18,152
So these are comparison operators.

386
00:22:18,152 --> 00:22:21,152
We also have what we call binary operators.

387
00:22:21,152 --> 00:22:26,192
These operators will process the variable's binary data directly.

388
00:22:26,192 --> 00:22:29,012
We'll go into more details later on,

389
00:22:29,012 --> 00:22:32,192
because it's not very useful for now.

390
00:22:32,192 --> 00:22:36,682
But it allows to process each of the bits contained in variables.

391
00:22:36,738 --> 00:22:40,418
Then we have shortcuts,

392
00:22:40,418 --> 00:22:42,798
which allow to facilitate the reading.

393
00:22:42,798 --> 00:22:46,668
For instance we can write "a += 10", that's just like

394
00:22:46,668 --> 00:22:49,468
writing "a = a + 10".

395
00:22:50,004 --> 00:22:52,334
We could write "a++", which is the same as

396
00:22:52,334 --> 00:22:54,104
writing "a = a + 1".

397
00:23:03,230 --> 00:23:06,537
We can write "/=", that's the same

398
00:23:06,537 --> 00:23:08,057
as doing a division.

399
00:23:08,057 --> 00:23:10,837
Those are just means to simplify writing.

400
00:23:10,837 --> 00:23:16,400
There are some special expression elements.

401
00:23:16,400 --> 00:23:20,820
For example 'A' returns the ASCII code

402
00:23:21,360 --> 00:23:23,590
for the character between apostrophes.

403
00:23:23,620 --> 00:23:27,760
Actually, the ASCII code for "A" is 65.

404
00:23:27,760 --> 00:23:30,760
ASCII codes are extremely important, as they allow us to

405
00:23:30,760 --> 00:23:32,460
display characters.

406
00:23:32,460 --> 00:23:37,210
There's an ASCII table, but we'll get back to this later on.

407
00:23:38,170 --> 00:23:40,390
We have the operator SIZEOF.

408
00:23:40,390 --> 00:23:42,100
We write "sizeof",

409
00:23:42,432 --> 00:23:45,432
the type of variable, of directly a variable,

410
00:23:45,694 --> 00:23:48,864
and this will return the size this variable take up in the memory.

411
00:23:48,864 --> 00:23:51,864
A last one: if we add an "&" before a variable,

412
00:23:51,864 --> 00:23:54,864
it'll return the address of this variable, in the memory.

413
00:23:56,625 --> 00:23:59,265
There's what we call a ternary operator,

414
00:23:59,265 --> 00:24:00,815
even if we rarely use it.

415
00:24:00,815 --> 00:24:05,615
The syntax is as follows : and expression, "?",

416
00:24:06,175 --> 00:24:09,317
a 2nd expression, ":", a 3rd expression,

417
00:24:09,582 --> 00:24:12,282
and it'll evaluate the fist expression.

418
00:24:12,282 --> 00:24:17,472
If the expression isn't NULL, it'll evaluate the second, and

419
00:24:17,472 --> 00:24:19,422
return it as a value.

420
00:24:19,542 --> 00:24:23,022
Or else, it'll evaluate the third expression, and return it as a value.

421
00:24:23,588 --> 00:24:26,138
So, it's a conditional expression.

422
00:24:26,196 --> 00:24:29,446
The last point, is what we call character strings.

423
00:24:29,446 --> 00:24:33,476
A string is a series of characters

424
00:24:33,936 --> 00:24:35,406
between inverted commas.

425
00:24:35,651 --> 00:24:39,231
This will allocate memory for the

426
00:24:39,231 --> 00:24:41,021
characters between inverted commas.

427
00:24:41,689 --> 00:24:45,949
It'll add a "\0" in the end, and it'll return the address

428
00:24:45,949 --> 00:24:48,820
of the first character.

429
00:24:49,800 --> 00:24:54,790
We've seen, when we listed types, that there's a particular type...

430
00:24:54,790 --> 00:24:56,360
Pointers.

431
00:24:57,000 --> 00:25:00,540
A pointer is a variable like the others,

432
00:25:00,540 --> 00:25:03,380
except that instead of storing data,

433
00:25:05,011 --> 00:25:07,353
it'll store the address of another variable,

434
00:25:07,353 --> 00:25:09,633
well at least the data's address.

435
00:25:09,633 --> 00:25:11,883
It's a pointer to something,

436
00:25:11,883 --> 00:25:13,913
so, as it name suggests,

437
00:25:13,913 --> 00:25:16,053
it contains the address of something.

438
00:25:16,057 --> 00:25:17,408
How to declare a pointer ?

439
00:25:17,408 --> 00:25:21,711
First we have to declare the type of what we point to,

440
00:25:21,711 --> 00:25:24,408
meaning the variable's type

441
00:25:24,420 --> 00:25:27,043
whose address we want to store.

442
00:25:27,043 --> 00:25:29,762
So we write the type, "*", the name.

443
00:25:31,341 --> 00:25:34,984
An example : If I write "int *p",

444
00:25:36,724 --> 00:25:40,554
"p" stores the address of a variable of type int.

445
00:25:41,531 --> 00:25:43,118
How do we use them?

446
00:25:43,118 --> 00:25:46,163
Quite simply.

447
00:25:48,965 --> 00:25:51,955
Once we've declared a pointer

448
00:25:51,955 --> 00:25:53,732
of type int,

449
00:25:54,675 --> 00:25:56,883
as I did just there.

450
00:25:57,169 --> 00:26:00,260
We write "p = &a".

451
00:26:01,139 --> 00:26:04,190
We'll set the address of "a" in "p".

452
00:26:06,642 --> 00:26:09,650
Then we'll use "*p".

453
00:26:11,757 --> 00:26:13,175
We do "p = 1;"

454
00:26:13,175 --> 00:26:18,867
it'll set "1" inside the address pointed by "p",

455
00:26:20,125 --> 00:26:22,580
It's the same as writing "a = 1",

456
00:26:22,580 --> 00:26:25,162
as "p" contains the address of "a",

457
00:26:25,738 --> 00:26:28,064
So if "p" contains the address of "a",

458
00:26:28,064 --> 00:26:32,752
"*p" is the same thing as "a",

459
00:26:33,403 --> 00:26:36,522
It's the same memory area, the same address

460
00:26:36,522 --> 00:26:37,863
and the same type.

461
00:26:39,718 --> 00:26:41,382
Basically,

462
00:26:41,382 --> 00:26:43,836
we can say that "*name"

463
00:26:44,816 --> 00:26:47,873
so "*" the name of a variable, of type pointer,

464
00:26:48,151 --> 00:26:50,456
is the object of type "type"

465
00:26:50,456 --> 00:26:52,449
whose addresses is stored in "name".

466
00:26:52,667 --> 00:26:54,227
That's very important.

467
00:26:54,227 --> 00:26:57,252
You must systematically refer to this definition.

468
00:26:57,252 --> 00:27:00,109
When I have a pointer called "name",

469
00:27:00,663 --> 00:27:02,345
of type "type",

470
00:27:02,345 --> 00:27:07,368
*name is the object of type "type", stored in "name.

471
00:27:09,389 --> 00:27:11,855
So we have an arithmetics system.

472
00:27:11,855 --> 00:27:16,609
Let's take an array "tab[42]",

473
00:27:16,609 --> 00:27:21,294
So "p", an object of type pointer, which stores

474
00:27:21,294 --> 00:27:24,772
the address of tab's first element.

475
00:27:25,888 --> 00:27:31,599
If we write "*(p + x)", we access the value located at the position "x"

476
00:27:31,599 --> 00:27:34,538
of our array,

477
00:27:34,558 --> 00:27:39,248
same as if we wrote "tab[x]".

478
00:27:40,188 --> 00:27:42,517
So. Up till now,

479
00:27:42,520 --> 00:27:44,928
we've seen variable declarations,

480
00:27:45,128 --> 00:27:47,847
instructions,

481
00:27:48,749 --> 00:27:51,215
and now we're left with control structures.

482
00:27:51,585 --> 00:27:53,832
In C, there are several control structures.

483
00:27:53,832 --> 00:27:56,431
We'll see 3.

484
00:27:57,620 --> 00:27:59,421
Actually, we'll see 4.

485
00:27:59,421 --> 00:28:01,563
Because 2 of them are very much alike.

486
00:28:01,563 --> 00:28:02,997
The first is...

487
00:28:03,379 --> 00:28:05,544
the control structure IF.

488
00:28:05,544 --> 00:28:07,019
It's quite simple :

489
00:28:07,019 --> 00:28:10,595
we write "if (expression)"

490
00:28:10,595 --> 00:28:12,882
and then, an instruction.

491
00:28:13,556 --> 00:28:15,643
This instruction can be a block,

492
00:28:15,811 --> 00:28:18,800
which means it can contain several instructions,

493
00:28:18,800 --> 00:28:19,990
and declarations.

494
00:28:19,990 --> 00:28:21,805
How does it work? It's simple :

495
00:28:21,805 --> 00:28:23,461
it evaluates the expression.

496
00:28:23,461 --> 00:28:26,221
So we're going to calculate the result of the expression.

497
00:28:26,545 --> 00:28:31,112
If the expression returns 0, it doesn't do anything.

498
00:28:31,913 --> 00:28:37,059
if it returns something else than 0, it'll execute the instruction.

499
00:28:38,190 --> 00:28:40,905
It's a simple test, and quite practical to use.

500
00:28:41,409 --> 00:28:44,476
There's a more elaborated version

501
00:28:44,588 --> 00:28:49,081
which is "if (expression){instruction}

502
00:28:49,081 --> 00:28:51,885
else {other instruction}"

503
00:28:52,257 --> 00:28:55,629
As you can imagine, it evaluates the expression.

504
00:28:55,629 --> 00:29:00,802
If the expression is worth 0, it executes the 2nd expression.

505
00:29:02,251 --> 00:29:05,890
If the expression is worth 1, it executes the 1st expression.

506
00:29:06,306 --> 00:29:08,929
It's a rather simple thing.

507
00:29:09,496 --> 00:29:12,493
Second control structure, the structure WHILE.

508
00:29:13,503 --> 00:29:19,492
The structure WHILE is quite simple : "while (expression),

509
00:29:20,493 --> 00:29:22,077
and an instruction.

510
00:29:22,377 --> 00:29:27,351
The process is a little different.

511
00:29:27,351 --> 00:29:29,544
The WHILE evaluates the expression.

512
00:29:30,037 --> 00:29:32,822
If the expression us worth 0, it stops.

513
00:29:32,879 --> 00:29:34,720
If it's worth something other than 0,

514
00:29:34,720 --> 00:29:36,241
we'll execute the instruction.

515
00:29:36,241 --> 00:29:38,892
So far, it's just like with an IF,

516
00:29:38,892 --> 00:29:42,462
except that instead of stopping here, we loop.

517
00:29:42,462 --> 00:29:46,700
Which means we re-evaluate the expression.

518
00:29:46,863 --> 00:29:50,549
If the expression is worth 0, we stop, else, we execute the instruction again,

519
00:29:50,549 --> 00:29:51,965
and we go back to the start.

520
00:29:52,850 --> 00:29:55,925
As it names suggests, we'll execute the instruction while

521
00:29:56,345 --> 00:29:58,405
the expression isn't worth 0.

522
00:29:59,345 --> 00:30:02,462
That's how all loops work.

523
00:30:02,462 --> 00:30:04,972
That's how you'll use them during this piscine.

524
00:30:04,972 --> 00:30:08,200
There are other control structures, but you'll just use these ones

525
00:30:08,200 --> 00:30:09,319
for now.

526
00:30:09,319 --> 00:30:10,998
The last control structure :

527
00:30:10,998 --> 00:30:13,518
The structure RETURN, which allows to

528
00:30:14,018 --> 00:30:16,586
return a value at the exit of a function.

529
00:30:16,586 --> 00:30:20,220
As we've seen, the function takes parameters as entries,

530
00:30:20,220 --> 00:30:23,022
and returns a value upon exit.

531
00:30:24,452 --> 00:30:26,555
RETURN allows us to return this value.

532
00:30:26,555 --> 00:30:36,510
return(_) calculates the expression, and stops the function.

533
00:30:36,510 --> 00:30:41,028
This means that if there are other instructions after this "return",

534
00:30:41,358 --> 00:30:43,538
they won't be executed.

535
00:30:43,868 --> 00:30:47,916
The function's return value will be the result of the expression.

536
00:30:48,166 --> 00:30:51,248
There's another type of RETURN without a return value,

537
00:30:51,248 --> 00:30:54,602
meant for a particular type of function

538
00:30:54,602 --> 00:30:56,472
we haven't seen yet,

539
00:30:56,472 --> 00:30:57,965
but you'll see that later.

540
00:30:57,965 --> 00:31:00,692
Those are functions that can't return values,

541
00:31:00,692 --> 00:31:03,803
and which have a different syntax.

542
00:31:04,053 --> 00:31:09,839
That's it for this lesson about C,

543
00:31:09,839 --> 00:31:12,582
or at least for what you need for this Piscine.
