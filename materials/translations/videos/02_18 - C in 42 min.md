Hello everyone, and welcome to this lesson : C in 42 minutes (almost) Before anything, small clarification : this lesson is not meant to teach you how to program in C. It's not an exhaustive description of the language. Its sole purpose is to bring forward elements you'll need to complete this piscine. It's a subset of C, which will allow you to accomplish everything that's asked of you during this piscine. Before even starting to write code, the 1st thing you need to understand is... What's a computer? What's in it? And how does it work? So, a machine is made of 3 elements. The first is the CPU. It's the one that processes all calculations, all comparisons, ... All of these actions are made by the CPU. The second element is the RAM. The RAM is a tool, an object that'll hold everything that's been memorised by the computer. So this second element is very important. And last, the 3rd element is made of computer peripherals/devices. That's what will allow you to connect your computer to the rest of the world. So we have those 3 elements. These 3 elements are interlinked by a system, called BUS which will allow information to be transferred. There's also a clock system,  which allows all of this to operate together. So, of course a computer is much more complex than what I've described. But that's, I would say, the image. or at least the representation we'll need during the rest of this piscine, and also, for a while, during 1st year at the school. So let's keep this basic description for now. I'll say it again: a processor (CPU), so a treatment unit, a memorisation system, which we call RAM, and a system of interface with the rest of the world in other words, devices. And programming, what does it mean? Programming, in the end, compared to what we've seen before, meaning the paradigm of the computer's description, consists in giving instructions to the processor, meaning a list of elementary actions which will handle data. So we'll be able to do extremely simple actions. Like, for example, comparing two data, a simple operation such as an addition, a subtraction or a division. We'll be able to relay an information in a new address, so, we'll be able to copy the data of an address into another. We'll be able to do basic arithmetics, basic comparisons, and we'll be able to send these data to a device, for example, display them onscreen, or simply forward them. What you need to understand, is that we're trying to do things that are extremely elementary, but that will be done extremely fast and in a very large quantity. These elementary instructions will allow us to simulate extremely complicated behaviors, maybe even simulate intelligence. However, today, our programming sytem won't be able to just do extremely elementary things. So what about C in all that? In the end, the computer will process a language, which is called computer-language, which is a very elementary language, directly made of codes that are particularly unpleasant for human beings. The C language is a layer above of this. It's a relatively simple language, that's close to the computer's language. Here, we'll have a sequential language which will, overall, have a translation in rather elementary operations. So nothing too complicated. However, it'll be readable and pretty simple to use by a human being. which will make this process efficient. So, we have a system that will be complicated, meaning we'll transform the C language into something we write in computer language. Then, this computer language will be executed by the processor, and it'll be readable by human beings, and it'll compile (so it's particularly efficient) all by letting a set of functionalities, that are relatively evolved, allowing us to function correctly. Another important layer to integrate, is the operating system. The operating system is the software that'll make the computer work. It'll be launched at the start-up, and will allow us to have an interface between the user and the machine. The OS, we'll see more complex definitions and descriptions later on, because it's a very complex object that's been elaborated with a lot of work for a very long time, The OS is the result of a strong evolution. This object will manage the entire functioning of the computer and your program will 'interface" itself with the OS. To be clear, when, for example, you'll want to display a character, your program, written in C, will tells the OS via what we call system-calls, "I want this character to be displayed" And it's the OS that'll do the job. Which means, in your program, you don't need to code the entire system, that'll lead to displaying a character. So, C will allow your to write simple instructions, which will allow you to "interface" with the OS, which will also "interface" itself with the hardware to display or to cary out the actions you need. As we've seen previously, the computer holds memory, so it holds data, and will be able to run processes on these data, so follow instructions. A C program, is the representation of not only data we'll process, which means we'll have information about these data, but also instructions. In the RAM, we'll depict the data by groups of 8, which we call bytes. It's a group of 8 bits, so 8, 1 and 0, we'll call that a byte. It allows us to represent numbers from 0 to 255, depending on their representation. and each of these bytes, will be given an address, which will allow us to recognise it, and find it. C will allow us to work on these bytes, and so work on the address system. C uses types to represent data, and so we'll have several types. The first type, is what we call CHAR, which is 8-bit, so a byte. So it can represent numbers from -128 to +127, and a basic arithmetics is affected to it, which will allow it to handles all usual processes: divisions, subtractions, etc... The second type is the UNSIGNED CHAR, which is also 8 bits, but that'll have another representation, which will go from 0 to 255. Then, you have what we call a SHORT, which is 2 bytes, out of 16-bits, which will allow us to represent from - 32 000 up to +32 000. You also have the UNSIGNED SHORT, skipping details... You have the INT, which is on 4 bytes, and it generally is the data structure we use the most, because it allows us to do most processes. You also have the UNSIGNED INT, the LONG, and the LONG LONG, which allow us to represent data up to 64 bits. You have the UNSIGNED LONG... And you have the last type, which is called the "star", "asterisk" or "pointer", which allows to hold not just a data, but the address of a data. We can consider that a data's address is also a data itself, but there's a special arithmetic that we'll see later on. Now that we know how to represent data, let's start talking about a program's structure. A program's structure, is a set of functions. What we call a function, is an entity said to be closed because data in this entity are supposed to be closed to the rest of the world, which get this information, which we call parameters, and which will return a result, and between the two we have a process, and we'll see how it works. A function is always made of two things: instructions, and local variables. Here, you see the first syntax element : the declaration of a function. A function can be declared rather simply. We define its type, meaning the type of what the function returns, because a function takes values as entries which we call parameters, and returns a result. So the type you see first on this prototype, is the return value's type. Then we have the function's name, and then the list of parameters, which are every time, the type of the 1st parameter, the name of the 1st parameter, the type of the 2nd parameter, the name of the 2nd parameter, etc, etc... There can be as many parameters as we want, there can also be none at all. If there's no parameter, we simply write opening parenthesis, closing parenthesis. That is what defines what the function returns, and what it takes for parameters, and right after, there's what we call a block. A block contains the function itself. A function is always split into two parts. The second part, the block, is between curly brackets. So there's an opening curly bracket, the declaration of local variables, followed by instructions, - There could be only one instruction, there could be no local variable, there could be no instruction - and we always end with a closing curly bracket. Here's a quick example of a small function. Here we'll declare a function called sum(), which returns an int, and which takes 2 parameters: a parameter "value1", which is of type int, and a 2nd parameter "value2", which is also an int. This function starts it block, so opening curly bracket. "int total" declares a new int called "total", and is a local variable to the function. The functions are closed, which means outside of the function, this variable doesn't exist. Therefore, it's local. Then we've got the instructions In this example, there aren't any, but that's where they'd be. And finally, the closing curly bracket: end of the block, end of the function. In C, we can declare what we call combined types. They're data structures which are made of elementary types, which we saw earlier on. There are a few, but during this piscine, we'll only use 2. The first is the array. An array is a succession of objects of the same type (in the memory). It's easily declared: type, name, opening square bracket, number of elements in the array, closing square bracket. You've got an example on the right : "int tab[42]", which is the declaration of an array, which can contain 42 ints. The array's index goes from 0 to 41. We always start at 0. So, with this array, you've reserved 42 ints in the memory. To access them, we write the name, opening square bracket, the number of the int we want, closing square bracket. For example, if we write "int tab[12]", we'll get the 13th int. The second combined type is a bit more complex, and we'll use it later on, is called data structure. The structure will allow us to define the representation of an object in memory, which will be made of basic elements, that could very well be structures too. You have to know we can interlink structures, arrays, etc... Let's check out how to declare a structure. we write "struct", the name of our structure, opening curly bracket, we declare this structure's components (type, name, etc...) closing curly bracket and semi-colon. Here, we've just declared a structure. There's an example on the right, where we declare a structure "s_fortytwo". It's made of an int called "a", and an array of 21 characters, called "b". We define it in a simple manner, indicated below. We declare the structure, and when we write "struct", name of the structure, name of the variable, semi-colon, it reserves the necessary memory area, and when we use this name, the program will know we're talking about a structure. The compiler in C is usually pretty permissive. In terms of syntax, you can write things in many different ways. But to make things more readable, and have some sort of consistency, we've defined a standard (Norm). This standard will be presented later on. You'll have a specific lesson on this topic. It's important for you to understand that using this standard has a lot of advantages. The 1st advantage is that it allows you to easily read each others code. The 2nd is that it helps learn how to program in a structured way. You'll see that even if you've already programmed before, the school's standard will still be an adjustment. It's biggest advantage is that it gives us a "look and feel" and helps for the reading. When we'll read someone else's code, being used to a standard will allow us to read faster. We please respect it. We have a program that checks whether the standard's been respected. We've seen that a program was a set of functions, and that there can be many functions. So where to start from? It has been defined, that in C syntax, originally, the function that will be executed first, the one that'll trigger the program's execution, is the function main(). So if you create a program, somewhere in your code, there'll be a function main(). It's a function that takes a certain number of parameters, you'll see later how they work and how to use th main() returns an int, but you'll see how this also works. This way, you'll systematically have this declaration : "int main", the parameters between parenthesis, if there are any, and the function's block. Now that we've seen the general structure of a program, and we've seen how to represent data, all that remains is how instructions work. Of course, now that we know how to declare data, we need to learn how to act on these data. It's quite simple. There are 3 types of instructions. There's what we call "blocks", which, as we've seen, are always made of an opening curly bracket, a collection of local variable declarations (local to the block), instructions which will be executed by that block, and a closing curly bracket. There's also what we call "expressions", which will be followed by a semi-colon, and make a numerical calculation, or evaluation, happen. We'll go into this later on. And then, we have what we call "control structures", which allows to control the proceedings of a series of instructions, inside a block. Let's start with expressions. So, expressions, as we've said, are a set of evaluations, which will give results. The simplest of evaluations, is a numerical value. For example, if you wrote a number, here 0 and 42, you can write it in hex (0XA), in octal (010), and it'll evaluate itself to its own value meaning that the compiler will make sure it's worth its result. The 2nd type of expression: Variables, Once we've got a variable, when we use it, it'll go evaluate directly to the variable's value. If, for instance, you have a value in an int "a", like in the example, when you write "a", it'll be worth the value that's in "a". Same thing for an array : If you wrote b[18], it'll look for the 19th element, held in "b". In the case of a structure, if you have a structure element called "sft_var.a", it'll look for the element "a" in the structure "sft_var". So a variable is evaluated directly by the value it contains. The 3rd type of expression is what we call function calls. We write the name of the function, the parameters we'll pass to this function, the compiler will call the function, and it'll be evaluated to the function's return value. We've seen that a function takes parameters for entry, does the process we ask it to do, and returns a value. So this value will be set instead of the function. In the following calculation, we'll have a function. We can combine all these elements thanks to computations. This way, the compiler will process the arithmetics, and, as you can see below, we can write very complicated things. If you write "1 + 3" it'll take the 1, and add 3 to it, "-", it handles parenthesis and priorities, operations, there's a b[0] which will get the first element of the array "b", when it'll write "a x 42", it'll go get the value of "a", it'll divide by the sum of 2 elements, returned by the function sum(). The compiler will manage to evaluate, calculate, the result of these arithmetic expressions and will do it in the right order. The last type of expressions : Assignations. An assignation, is, for instance, when we write "a = 42". The compiler will set the value "42" to the variable "a", and will return, as a result, 42. We'll systematically have an assignation and an evaluation. For example, if you write "b[2 + a]", we'll go get the value contained in "a", and add 2 to it. This value serves as an index, to go read in the array "b". We'll calculate the result of the function that's on the right, we'll assign it in the array, and we'll return, as a result, the function's result. It's an assignation, and it'll modify the data in the variable. There are other expressions. We have what we call comparisons. A comparison in C, is an operator which will be evaluated, just like any other expression, to a value. We call TRUE, the return value 1, and FALSE, the return value 0. So when you write, for instance, "a == b", it'll check if the content of variable "a" is equal to the content of variable "b". If both contents are equal, it'll return 1, else it'll return 0. All comparators work the same way. Another example, if you write "a < b", it'll check the values of "a" and "b", if "a" is indeed inferior to "b", it'll return 1, else it'll return 0. As operators, you have "==", which compares equality, "!=" means "different than", "<", ">", "<=", ">=", "||" (logical OR), "&&" (logical AND) and "!!" which is a negation. If we write "!a", if "a" is worth 0, then it return 1, else it returns 0. So these are comparison operators. We also have what we call binary operators. These operators will process the variable's binary data directly. We'll go into more details later on, because it's not very useful for now. But it allows to process each of the bits contained in variables. Then we have shortcuts, which allow to facilitate the reading. For instance we can write "a += 10", that's just like writing "a = a + 10". We could write "a++", which is the same as writing "a = a + 1". We can write "/=", that's the same as doing a division. Those are just means to simplify writing. There are some special expression elements. For example 'A' returns the ASCII code for the character between apostrophes. Actually, the ASCII code for "A" is 65. ASCII codes are extremely important, as they allow us to display characters. There's an ASCII table, but we'll get back to this later on. We have the operator SIZEOF. We write "sizeof", the type of variable, of directly a variable, and this will return the size this variable take up in the memory. A last one: if we add an "&" before a variable, it'll return the address of this variable, in the memory. There's what we call a ternary operator, even if we rarely use it. The syntax is as follows : and expression, "?",  a 2nd expression, ":", a 3rd expression, and it'll evaluate the fist expression. If the expression isn't NULL, it'll evaluate the second, and return it as a value. Or else, it'll evaluate the third expression, and return it as a value. So, it's a conditional expression. The last point, is what we call character strings. A string is a series of characters between inverted commas. This will allocate memory for the characters between inverted commas. It'll add a "\0" in the end, and it'll return the address of the first character. We've seen, when we listed types, that there's a particular type... Pointers. A pointer is a variable like the others, except that instead of storing data, it'll store the address of another variable, well at least the data's address. It's a pointer to something, so, as it name suggests, it contains the address of something. How to declare a pointer ?First we have to declare the type of what we point to, meaning the variable's type whose address we want to store. So we write the type, "*", the name. An example : If I write "int *p", "p" stores the address of a variable of type int. How do we use them? Quite simply. Once we've declared a pointer of type int, as I did just there. We write "p = &a". We'll set the address of "a" in "p". Then we'll use "*p". We do "p = 1;" it'll set "1" inside the address pointed by "p", It's the same as writing "a = 1", as "p" contains the address of "a", So if "p" contains the address of "a", "*p" is the same thing as "a", It's the same memory area, the same address and the same type. Basically, we can say that "*name" so "*" the name of a variable, of type pointer, is the object of type "type" whose addresses is stored in "name". That's very important. You must systematically refer to this definition. When I have a pointer called "name", of type "type", *name is the object of type "type", stored in "name. So we have an arithmetics system. Let's take an array "tab[42]", So "p", an object of type pointer, which stores the address of tab's first element. If we write "*(p + x)", we access the value located at the position "x" of our array, same as if we wrote "tab[x]". So. Up till now, we've seen variable declarations, instructions, and now we're left with control structures. In C, there are several control structures. We'll see 3. Actually, we'll see 4. Because 2 of them are very much alike. The first is... the control structure IF. It's quite simple : we write "if (expression)" and then, an instruction. This instruction can be a block, which means it can contain several instructions, and declarations. How does it work? It's simple : it evaluates the expression. So we're going to calculate the result of the expression. If the expression returns 0, it doesn't do anything. if it returns something else than 0, it'll execute the instruction. It's a simple test, and quite practical to use. There's a more elaborated version which is "if (expression){instruction} else {other instruction}" As you can imagine, it evaluates the expression. If the expression is worth 0, it executes the 2nd expression. If the expression is worth 1, it executes the 1st expression. It's a rather simple thing. Second control structure, the structure WHILE. The structure WHILE is quite simple : "while (expression), and an instruction. The process is a little different. The WHILE evaluates the expression. If the expression us worth 0, it stops. If it's worth something other than 0, we'll execute the instruction. So far, it's just like with an IF, except that instead of stopping here, we loop. Which means we re-evaluate the expression. If the expression is worth 0, we stop, else, we execute the instruction again, and we go back to the start. As it names suggests, we'll execute the instruction while the expression isn't worth 0. That's how all loops work. That's how you'll use them during this piscine. There are other control structures, but you'll just use these ones The last control structure : The structure RETURN, which allows to return a value at the exit of a function. As we've seen, the function takes parameters as entries, and returns a value upon exit. RETURN allows us to return this value. return(_) calculates the expression, and stops the function. This means that if there are other instructions after this "return", they won't be executed. The function's return value will be the result of the expression. There's another type of RETURN without a return value, meant for a particular type of function we haven't seen yet, but you'll see that later. Those are functions that can't return values, and which have a different syntax. That's it for this lesson about C, or at least for what you need for this Piscine.



> Buna ziua tuturor si bine ati venit la acest curs de limbaj C in 42 de minute, sau pe-aproape.

> înainte de toate, o mica precizare: acest curs nu isi propune sa va invete sa programați in C, el nu da o descriere completa a limbajului.

> Scopul sau este doar sa va prezinte elementele de care aveți nevoie pentru a rezolva exercițiile din Piscina.

> Este un subset al limbajului C, care va va permite sa rezolvați tot ce va vom cere pe parcursul Piscinei.

> înainte sa începem sa programam, primul lucru pe care trebuie sa-l intelegem este:

> Ce anume este un computer? Ce are in interior? Cum funcționează acesta?

> Un computer este alcătuit din 3 elemente.

> Primul element este procesorul ("CPU"). El face toate operațiile, calculele si comparațiile, tot ce face unitatea centrala.

> Al doilea element este memoria interna ("RAM").

> Este componenta care conține tot ce este memorat de către computer. Este un element foarte important.

> Al treilea element sunt perifericele, cele care fac legătură intre computer si lumea exterioara.

> Aceste trei elemente sunt legate intre ele printr-un sistem de "bus", care permite transportul informației.

> Mai avem si un sistem de temporizare care permite funcționarea elementelor impreuna.

> Bineînțeles ca un computer este mult mai complex decât in aceasta descriere,

> dar aceasta e imaginea, reprezentarea de care avem nevoie pe parcursul Piscinei si chiar o buna parte din primul an.

> Vom ramane la aceasta descriere foarte sumara.

> Sa recapitulam: un procesor, deci o unitate de prelucrare a datelor,

> un sistem de memorie pe care il numim RAM si un sistem de interfatare cu restul lumii sub numele de periferice.

> Ce inseamna sa programam?

> A programa, in contextul descrierii anterioare, adica in paradigma computerelor,

> inseamna sa dam instrucțiuni procesorului, adica o lista de acțiuni elementare,

> care vor avea in mod sistematic efectul de a manipula date.

> Vom putea face operații extrem de simple, ca de exemplu compararea valorilor,

> sa facem operații simple precum adunarea, scăderea, impartirea,

> sau sa trimitem o valoare la o adresa noua, adica sa copiem informația de la o adresa la alta.

> Vom putea face aritmetica de baza, comparații de baza,

> si vom putea trimite valorile spre periferice, de exemplu sa le afișam pe ecran si altele de acest gen.

> Ce este foarte important sa înțelegem este ca ceea ce facem sunt operații elementare,

> care in schimb se vor executa extrem de rapid, deci foarte multe,

> ceea ce va permite, cu ajutorul acestor instrucțiuni elementare,

> simularea unor comportamente foarte complexe, putând ajunge chiar sa simulam inteligenta.

> In orice caz, pentru moment, sistemul de programare va fi capabil sa execute doar lucruri foarte elementare.

> Așadar, unde intervine limbajul C in toata aceasta poveste?

> La urma urmei, computerul va trata un limbaj numit "limbaj mașina", care este un limbaj elementar compus direct din cod mașina, fiind destul de incomod pentru om.

> Limbajul C este un strat superior, adica este un limbaj destul de simplu, care este relativ apropiat de limbajul mașina,

> fiind secvențial, care va avea o traducere in general directa in operații elementare, deci nu foarte complex, dar care va fi lizibil destul de ușor de om.

> Aceasta ne permite sa fim eficienți, pentru ca avem un limbaj care poate fi compilat,

> adica vom transforma codul C pe care il scriem in limbaj mașina, care va fi apoi executat de procesor.

> Este in același timp si lizibil de către om, dar si compilabil, deci foarte eficace, avand totuși acces la operații relativ evoluate care ne permit sa ne descurcam.

> Mai este un nivel pe care trebuie sa-l luam in considerare, si anume sistemul de operare.

> Este vorba de programul care face sa funcționeze computerul,

> deci care este lansat la pornirea calculatorului si care ne permite sa avem o interfața intre utilizator si computer.

> Pentru sistemul de operare vom vedea in viitor definiții mult mai complete,

> deoarece vorbim de un program foarte complex, pentru care s-a muncit mult ca volum si timp, fiind deci rezultatul unei lungi evoluții.

> Acest program gestionează totalitatea funcționarii computerului, iar programul vostru va folosi interfața cu sistemul de operare.

> Pentru a clarifica, de exemplu atunci când vreți sa afișați un caracter, programul vostru pe care il scrieți in limbaj C va cere sistemului de operare,

> printr-un sistem numit "apeluri sistem", sa afișeze caracterul, iar sistemul de operare este cel care face acest lucru.

> Ca atare, in programul vostru nu aveți nevoie sa programați toata partea din sistem care este necesara pentru afișarea caracterului.

> Limbajul C va permite sa scrieți o serie de instrucțiuni destul de simple, care va permit sa folosiți sitemul de operare,

> care la rândul sau va folosi interfețele materiale pentru afisaj, sau pentru alte operații de care vej avea nevoie.

> După cum am văzut mai devreme, computerul dispune de o memorie in care poate păstră date

> si va fi capabil sa faca operații cu aceste date in urma instructunilor primite.

> Un program in C este in același timp o reprezentare a datelor pe care le manipulam,

> adica o descriere a acestor date, dar include de asemenea si instrucțiunile.

> In memoria RAM datele (binare) se reprezintă in grupuri de cate 8, ceea ce numim octeti. Este un grup de 8 biți.

> 8 de O si de 1 sunt numiți împreuna un octet, iar acesta permite sa păstrăm numere intre 0 si 255, in funcție de reprezentarea lor.

> Fiecare octet are atribuita o adresa, care permite sa fie accesat.

> Limbajul C permite operațiile cu acești octeti, deci manipularea acestui sistem de adrese.

> Limbajul C folosește tipuri pentru a reprezenta datele, ca atare vom avea mai multe tipuri.

> Primul tip este cel numit "char", care este constituit din 8 biți, adica un octet cum tocmai am văzut.

> El permite reprezentarea valorilor de la -128 pana la +127, fiindu-i asociata o aritmetica clasica,

> ce permite toate operațiile obișnuite, cum ar fi impartirea, scăderea etc.

> Un al doilea tip este "unsigned char", constituit de asemenea din 8 biți, dar cu alta reprezentare, avand valori de la 0 pana la 255.

> Urmeaza tipul numit "short", constituit din doi octeti, pe 16 biți, care permite reprezentarea valorilor intre minus 32 de mii si plus 32 de mii.

> La fel, avem "unsigned short", dar voi sari peste detalii.

> Apoi tipul "int" pe 4 octeti, care este in general tipul pe care il utilizam cel mai mult, deoarece acopera majoritatea necesităților.

> De asemenea tipul "unsigned int", dar si "long" si "long long",

> care permit reprezentarea valorilor numerice pana la 64 de biți. Avem si "unsigned long", desigur.

> Mai exista un ultim tip numit (steluta), sau "pointer", si care permite memorarea nu a unei valori numerice, ci a unei adrese de memorie.

> Putem considera ca o adresa este si ea tot o valoare numerica, dar avem o aritmetica speciala pentru aceste valori, asa cum vom vedea in continuare.

> Acum ca știm cum se reprezintă valorile numerice, vom vorbi de structura programelor.

> Structura unui program consista dintr-un ansamblu de funcții.

> Ceea ce numim "funcție" este o entitate pe care o numim ermetica,

> pentru ca variabilele din interior sunt inaccesibile din exterior,

> care primește informații prin intermediul parametrilor

> si care va furniza un rezultat, iar intre cele doua avem procesarea datelor.

> Vom vedea imediat cum funcționează.

> Orice funcție este compusa din doua parti: instrucțiuni si variabile locale.

> Aici puteti vedea un prim exemplu de sintaxa pentru declararea unei funcții.

> O funcție se declara destul de simplu. Definim tipul ei, adica tipul rezultatului furnizat de funcție.

> Am văzut anterior ca funcția primește valori, prin parametrii si furnizează un rezultat.

> Așadar, tipul de la început este tipul valorii furnizate de funcție.

> Apoi avem numele funcției, iar apoi avem lista de parametri, precizând pentru fiecare tipul si numele lor, separandu-i cu virgula.

> Putem avea oricati parametri si se poate sa nu avem nici unul, caz in care scriem paranteza deschisa si paranteza inchisa.

> Asa definim ceea ce furnizează funcția si ce parametri primește ea.

> Urmeaza imediat un bloc ("block"). Blocul conține funcția propriu-zisa.

> O funcție se descompune întotdeauna in doua parti, cum vedeți mai jos:

> intre cele doua acolade avem partea de declarare a variabilelor locale, urmata de instrucțiuni.

> Putem avea oricâte instrucțiuni. Putem sa nu avem variabile locale, nici instrucțiuni. Un bloc se termina intotdeauna cu o acolada inchisa.

> Va prezint repede un exemplu de funcție simpla.

> lata primul exemplu de funcție.

> Aici declaram o funcție care se numește suma ("sum"), care furnizează ca rezultat un intreg ("int") si care primește doi parametri.

> Un parametru se numește "valuel" de tip "int" si al doilea tot de tip "int", numit "value2".

> După aceea deschidem blocul, cu o acolada deschisa.

> Cu "int total" declaram o variabila locala de tip intreg.

> Când vorbim de "local", este pentru ca suntem in interiorul funcției, care este etanșa.

> Adică aceasta variabila locala nu exista in exteriorul funcției.

> Urmeaza apoi instrucțiunile. Nu am dat exemplu de instrucțiuni, dar macar sa stiti ca aici se situează ele.

> Scriind acolada inchisa, terminam blocul si deci si funcția.

> In limbajul C putem declara tipuri compuse.

> E vorba de structuri de date compuse din tipuri elementare din lista cele prezentate anterior.

> Avem doua tipuri de structuri principale, exista si altele, dar nu ne ocupam de ele deocamdată.

> Pentru piscina le vom folosi doar pe cele doua.

> Primul tip este tabloul. Un tablou este pur si simplu un sir, o serie de elemente de același tip, repetate in memorie.

> Acesta se declara destul de ușor: tipul, numele tabloului, paranteza patrata deschisa,

> numărul elementelor din tablou si paranteza patrata inchisa.

> In partea dreapta aveți un exemplu: "int tab[42]". Aceasta este o declarație de tablou de 42 de intregi.

> La nivel de indexare, aceasta merge de la O la 41, pentru ca incepem intotdeauna de la zero.

> Acesta este un tablou; asa rezervam in memorie 42 de intregi, la care putem avea acces la fiecare pentru a-i folosi.

> Scriem numele, si intre paranteze patrate numărul intregului pe care-l dorim,

> de exemplu daca scriem ”tab[12]", vom obține al 13-lea intreg.

> Al doilea tip compus, ceva mai complex, pe care il vom folosi ceva mai târziu, sunt structurile de date.

> Structurile ne permit sa definim de fapt o reprezentare a unui obiect in memorie,

> obiect care va fi compus la rândul lui din elemente mai simple, dar care pot de asemenea sa fie structuri. Putem imbrica structuri, tablouri etc.

> O structura se definește după cum urmeaza: cuvântul cheie "struct", numele structurii, acolada deschisa, declarația componentelor structurii,

> pentru care precizam tipul si numele lor, acolada inchisa si terminam cu punct si virgula. Tocmai am declarat o structura.

> Vedeți in dreapta un exemplu, unde declaram o structura numita "s_fortytwo".

> Ea este compusa dintr-un întreg "a" si un tablou de 21 de caractere numit "b".

> Declarația structurii este destul de simpla, asa cum se vede aici.

> Declarația structurii este destul de simpla, asa cum se vede aici.

> Când scriem "struct", numele structurii, numele componentei si apoi punct si virgula, rezervam in memorie spațiul necesar,

> iar când vom folosi acest nume, interpretorul va sti ca este vorba de o structura.

> In general, compilatorul limbajului C este destul de flexibil, la nivel de sintaxa, adica putem scrie același lucru in mai multe feluri diferite.

> Pentru a face scrierea programelor cat mai lizibila si pentru a asigura o oarecare omogenitate, am definit o norma.

> Aceasta norma va va fi prezentata ceva mai târziu, veți avea un curs dedicat acestui subiect,

> totuși, ceea ce este important sa intelegeti este ca folosirea acestei norme prezintă un mare interes.

> In primul rând, aceasta permite colaborarea intre voi sporind lizibilitatea programelor.

> In al doilea rând, aceasta va va ajuta sa invatati sa programați in mod structurat.

> Veți vedea ca, aceasta norma, deși pentru cei care au invatat singuri sa programeze poate fi o constrângere importanta,

> ea are si un foarte mare avantaj, îmbunătățind aspectul final si ajutand la lizibilitatea codului.

> Cu alte cuvinte, când veți citi codul scris de un alt coleg, fiind obisnuiti cu norma, va permite sa il intelegeti mult mai repede.

> Va recomand deci sa o respectați cu strictete, cu atat mai mult cu cat vom avea un sistem de validare ce va verifica respectarea normei.

> Am văzut ca un program C este un ansamblu de funcții, putând fi vorba chiar de foarte multe funcții.

> Avem insa o problema si anume ca trebuie sa începem de undeva.

> Este definit, in sintaxa limbajului C, ca prima funcție care se executa,

> cea care declanșează execuția programului, este funcția "main".

> De aceea, când scrieți un program, este necesar ca undeva in acesta sa aveți declarata o funcție "main

> care primește o serie de parametri, după cum veți vedea mai târziu si care furnizează un rezultat de tip intreg.

> Vezi vedea de asemenea cum funcționează.

> Veți avea deci, in mod sistematic, o funcție numita "int main()", cu eventuali parametri in paranteza, iar apoi restul acesteia.

> Acum ca am văzut structura generala a unui program si cum putem reprezenta datele, ne ramane sa lămurim problematica instrucțiunilor.

> O data ce știm cum putem declara datele, trebuie sa vedem cum facem acțiuni si operații asupra lor.

> Pentru instrucțiuni e destul de ușor: avem trei tipuri de instrucțiuni.

> Primul e "blocul" pe care l-am văzut deja.

> Un bloc e întotdeauna alcătuit dintr-o acolada deschisa, o serie de declarații de variabile locale pentru acel bloc,

> o serie de instrucțiuni executate in bloc si o acolada inchisa.

> Al doilea tip este "expresia".

> Expresia este ceva urmat de punct si virgula si care efectuează un calcul, o evaluare numerica.

> Expresia este ceva urmat de punct si virgula si care efectuează un calcul, o evaluare numerica.

> Vom intra in delatii ceva mai târziu.

> Al treilea si ultimul sunt "structurile de control",

> care permit controlul modului de derulare al unei serii de instrucțiuni in interiorul unui bloc.

> Vom începe cu expresiile.

> Expresiile, asa cum sugerează numele, sunt o serie de calcule care dau un rezultat.

> Cea mai simpla evaluare este direct o valoare numerica.

> Putem folosi o cifra sau un număr, aici in exemplu avem 0 (zero) si 42.

> Putem scrie valoarea in hexa (baza 16) ca de exemplu "0x1 A" sau in octal (baza 8) precum "010".

> Acestea se evalueaza direct la valoarea lor, deci compilatorul va face in asa fel incat sa reprezinte valoarea rezultatului.

> Al doilea gen de expresie sunt variabilele.

>  Când scriem numele unei variabile, aceasta va returna valoarea ei.

> Daca aveți de exemplu un număr intreg care se numește "a", când scrieți "a", aceasta se va evalua la valoarea continua in "a”.

> Le fel pentru un tablou, daca scrieți ”b[18]", aceasta se va evalua cu valoarea celui de-al 19-lea element din tablou.

> De asemenea, aveți exemplul unei structuri, variabila care se numește "sft_var.a" se va evalua cu valoarea elementului "a" din structura.

> Pe scurt, o variabila se evalueaza direct la valoarea conținuta in ea.

> Al treilea gen de expresie este apelul la o funcție.

> Pentru a face apel la o funcție, scriem numele funcției si parametrii trimiși intre paranteze.

> Compilatorul va face in asa fel incat va apela funcția, iar valoarea rezultata este cea returnata de funcție,

> pentru ca am văzut mai devreme ca o funcție primește niște valori ca parametri, face calculele in interior si furnizează o valoare,

> iar aceasta valoare va înlocui apelul funcției in expresie.

> Bineînțeles, putem combina toate aceste feluri de expresii, folosind reguli de calcul.

> Compilatorul trateaza operațiile si regulile aritmetice. Asa cum vedeți in exemplu, putem scrie expresii destul de complicate.

> Daca scrieți "1 + 3" se va evalua suma respectiva, apoi se scade rezultatul din paranteza, pentru ca se respecta prioritățile.

> Vedeți in mijloc este un ”b[0]", care va cauta prima valoare din tabloul "b",

> când scriem "a * 42", se va folosi valoarea lui "a", apoi se va imparti cu valoarea sumei a ... ceva.

> când scriem "a * 42", se va folosi valoarea lui "a", apoi se va imparti cu valoarea sumei a ... ceva.

> Pentru asta se apeleaza funcția "sum" cu parametrii, ea va face calculele si va returna un rezultat care va fi folosit in expresie.

> Compilatorul se va descurca pentru a evalua valorile expresiilor aritmetice si o va face in ordinea normala, asa cum e si intuitiv.

> Ultimul gen de expresie sunt "atribuirile".

> O atribuire este când scriem de exemplu "a = 42".

> li spunem deci compilatorului sa pună valoarea 42 in variabila "a", iar aceasta operație va returna rezultatul "42".

> Vom avea deci o afectare de valoare, dar in mod sistematic si o evaluare.

> De exemplu aveți "b[2 + a]". Ce se va întâmpla aici?

> Compilatorul va lua valoarea lui "a", ii va aduna 2.

> Aceasta valoare va fi folosita ca index pentru tabloul "b", vom calcula rezultatul funcției din dreapta,

> si il vom introduce in tablou si vom trimite ca rezultat, rezultatul funcției.

> Deci e o atribuire care va modifica datele din variabila.

> Mai avem si alte expresii, ceea ce numim comparatorii,

> care sunt operatori a căror evaluare va rezulta (ca pentru toate expresiile) intr-o valoare.

> Numim "adevarata" valoarea de retur 1, si 0 când rezultatul e fals.

> Ceea ce inseamna ca atunci când puneți "a == b", va testa daca conținutul variabilei "a" e egal cu conținutul variabilei "b",

> si daca conținutul e egal va returna 1, daca nu, va returna 0.

> Toți comparatorii funcționează la fel.

> Adică daca scrieți "a < b", la fel, se va uita la valoarea lui "a", apoi valoarea lui "b",

> daca "a" chiar e mai mic decât "b", va returna 1, daca nu, va returna 0.

> Deci aveți "==" (comparator de egalitate), "!=" (care inseamna diferit), "<", ">", ">=",

> "||" (sau), "&&" (si), care sunt "sau logic" si "si logic", si "!" care e negarea.

> Daca scriem "!a", daca "a" e O, va returna 1, daca nu, va returna 0.

> Aceștia sunt operatorii de comparație.

> Avem si ceea ce se numește operatori binari. Operatorii binari vor lucra direct pe datele binare ale unei variabile.

> Vom intra mai târziu in detalii, nu e ceva foarte util pentru inceput, dar veți vedea ca permite sa tratati fiecare bit dintr-o variabila.

> Apoi avem scurtaturi, care ne permit sa simplificam ceea ce scriem.

> De exemplu putem scrie "a += 10", si e exact același lucru ca si cum am scrie "a = a + 10".

> Putem scrie "a++", si e ca si cum am scrie "a = a + 1".

> Putem scrie... "/=" si e ca si cum am face impartirea.

> Acestea sunt doar moduri de a simplifica ceea ce scriem.

> Avem ceva expresii speciale, de exemplu ’A' returneaza codul ASCII al caracterului dintre apostroafe. In exemplul de fata, codul ASCII al lui "A" e 65.

> Codurile ASCII sunt foarte importante, pentru ca ele ne permit sa afișam caractere.

> Deci avem un tabel ASCII, vom vorbi mai târziu despre el, care ne permite sa folosim direct caracterele.

> Avem operatorul "sizeof'. Scriem "sizeof' si un tip de variabila, sau direct variabila, si va va returna marimea acestei variabile in memorie.

> Si ultimul operator, putem face pe o variabila, si va returneaza adresa acestei variabile in memorie.

> Mai avem si operatorul ternar, chiar daca-l vom folosi destul de rar, care e un operator de tipul "expresiei ? expresie2 : expresie3".

> Va evalua prima expresie, daca expresia nu e nula, va evalua expresia 2 si ii va returna valoarea, daca nu, va evalua expresia 3 si ii va returna valoarea.

> E o expresie condiționala.

> Ultimul punct sunt șirurile de caractere. Un sir de caractere incepe cu ghilimele ("), urmate de o serie de caractere, si se termina cu alte ghilimele (”).

> Aceasta va aloca in memorie caracterele dintre ghilimele, va adauga un 0 la sfarsit, si va returna adresa primului caracter.

> Asta numim un sir de caractere.

> Am văzut când am enumerat toate tipurile, exista un tip particular numit pointer.

> Pointerul e o variabila ca si celelalte, dar care in loc sa conțină o valoare, va conține adresa unei alte variabile, sau in orice caz o adresa de date.

> E un pointer către ceva, cum indica numele, conține adresa unei date.

> Cum se declara: se declara începând cu tipul a ceea ce pointam, deci tipul variabilei a cărei adresa o va conține.

> Deci punem tipul, "*" si numele.

> Un exemplu: daca scriu "int *p", "p" conține adresa unei variabile de tip intreg.

> Cum se folosește? Destul de simplu.

> O data declarata (vom pleca de la principiul ca am declarat un pointer de tip "int" cum am făcut mai sus), scriem: "p = &a;".

> Vom pune in "p" adresa lui "a". Totul e ok.

> Apoi vom folosi "*p = 1care va pune 1 in adresa pointata de "p". E ca si cum as scrie "a = 1;".

> Pentru ca "p" conține adresa lui "a".

> Daca "p" conține adresa lui "a", atunci ”*p" e același lucru ca si "a".

> E aceeași memorie, aceeași adresa, si e același tip.

> In mod general, putem zice ca "*nume" (deci "*" plus numele unei variabile care e de tip pointer),

> e obiectul de tip "tip", al cărei adresa e conținuta in "nume".

> Acesta e un lucru foarte important, va trebui sa reveniți in mod sistematic la aceasta definiție.

> Când am un pointer care se numește "nume" care e de tip "tip", "*nume" e obiectul de tip "tip" conținut in "nume".

> Avem si un sistem aritmetic pentru pointeri.

> Când avem un obiect de tip pointer putem adresa acest pointer ca si un tablou.

> Deci "p[n]" vom accesa al "n" -lea element al acestui tabel.

> Utlimul punct pe care-l vom vedea, acum ca am văzut si declararea variabilelor, si instrucțiunile, sunt structurile de control.

> C-ul conține mai multe structuri de control, vom vedea acum trei dintre ele.

> De fapt vom vedea patru, pentru ca sunt doua foarte asemanatoare.

> Prima e structura de control "if'. E destul de simpla: scriem "if (expresie)", si apoi o instrucțiune. O instrucțiune care poate fi si un bloc.

> Deci poate sa conțină mai multe instrucțiuni si declarații.

> Modul de funcționare e simplu: evalueaza expresia, deci calculează rezultatul expresiei, daca expresia are valoarea 0, e ușor, nu face nimic.

> Daca expresia are alta valoare decât 0, va executa instrucțiunea.

> E un test destul de simplu, si ușor de folosit.

> Avem si o versiune mai complexa, care e "if (expresie)" apoi o instrucțiune, "else" plus alta instrucțiune.

> Cum va puteti imagina e destul de simplu, evalueaza expresia, daca expresia e O, executa a doua instrucțiune, daca expresia e 1, executa prima instrucțiune.

> Deci si aici avem ceva destul de simplu.

> A doua structura de control pe care o vom vedea e "while". Structura "while" e destul de simpla, la fel avem "while (expresie) instrucțiune".

> Funcționează puțin diferit, "while" evalueaza expresia, daca expresia e 0, se oprește, daca expresia nu e 0, vom executa instrucțiunea (pana aici e la fel ca "if").

> Dar in loc sa se oprească aici, reincepem.

> Deci reîncepem si reevaluam expresia, daca expresia e O, ne oprim, daca nu executam instrucțiunea, etc.

> Cum ii spune numele, vom executa instrucțiunea cat timp expresia nu e 0.

> Asa veți face toate buclele in piscina.

> Mai sunt si alte intrusctiuni pentru bucle, dar deocamdată pe aceasta o veți folosi deocamdată.

> Si ultima structura pe care o vom vedea, e structura "return" care permite sa returnam o valoare la ieșirea dintr-o funcție.

> Cum am văzut funcția ia niște parametri la intrare, si la ieșire retumeaza o valoare, "return" permite returnarea acestei valori.

> Daca facem "return (expresie)", va evalua expresia, va calcula expresia, si va opri funcția

> (deci funcția se va opri acolo unde a ajuns, si daca mai sunt instrucțiuni după acest "return", nu sunt executate)

> si valoarea de retur a funcției va fi rezultatul expresiei.

> Exista si o alta forma de "return" la care nu avem valoare de retur.

> Ar folosi la un alt tip de funcții pe care nu l-am văzut pana acum, dar pe care-l vom vedea mai târziu.

> Avem funcții care pot sa nu returneze o valoare, si au o sintaxa puțin diferita pe care o vom vedea mai târziu.

> Am terminat cu partea de C de care aveți nevoie pentru piscina.